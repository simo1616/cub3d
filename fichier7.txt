#ifndef CUB3D
# define CUB3D


# include <unistd.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>
# include <mlx.h>
# include <libft.h>
# include <fcntl.h>

# define ERR_OPEN_FILE "Error\nImpossible d'ouvrir le fichier: "
# define ERR_MEM_ALLOC_TEXTURE "Error\nÉchec de l'allocation mémoire pour textures.\n"
# define ERR_EMPTY_TEXTURE_PATH "Error\nChemin de texture vide.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_NO "Error\nTexture NO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_SO "Error\nTexture SO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_WE "Error\nTexture WE déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_EA "Error\nTexture EA déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_NO "Error\nÉchec de l'allocation mémoire pour texture NO.\n"
# define ERR_MEM_ALLOC_TEXTURE_SO "Error\nÉchec de l'allocation mémoire pour texture SO.\n"
# define ERR_MEM_ALLOC_TEXTURE_WE "Error\nÉchec de l'allocation mémoire pour texture WE.\n"
# define ERR_MEM_ALLOC_TEXTURE_EA "Error\nÉchec de l'allocation mémoire pour texture EA.\n"
# define ERR_MEM_ALLOC_COLOR "Error\nÉchec de l'allocation mémoire pour couleur.\n"
# define ERR_INVALID_COLOR_FORMAT "Error\n Invalid color format (need exactly 3 values)\n"
# define ERR_INVALID_COLOR_VALUE "Error\nCouleur invalide: \n"
# define ERR_UNKNOWN_COLOR_IDENTIFIER "Error\nIdentifiant de couleur inconnu \n"
# define ERR_MAP_FIRST_LAST_LINE "Error\nLigne (1ère/dernière) contient autre chose que '1'.\n"
# define ERR_MAP_START_LINE "Error\nUne ligne ne commence pas par un mur '1'.\n"
# define ERR_TEXTURE_NOT_DEFINED_NO "Error\nTexture NO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_SO "Error\nTexture SO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_WE "Error\nTexture WE non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_EA "Error\nTexture EA non définie.\n"
# define ERR_COLOR_NOT_DEFINED_F "Error\nColeur F(Sol) non définie.\n"
# define ERR_COLOR_NOT_DEFINED_C "Error\nColeur C(Plaf.) non définie.\n"
# define ERR_MAP_NOT_DEFINED "Error\nmap non définie.\n"
# define ERR_MAP_EMPTY "Error\nMap vide.\n"
# define ERR_MAP_INVALID_CHAR "Error\nCaractère invalide.\n"
# define ERR_MAP_TEXT_MORE_THAN_ONE "Error\nIl faut exactement 1 orientation (N,S,E,W).\n"
# define ERR_MAP_MALLOC "Error\nMalloc failed for visited.\n"
# define ERR_MAP_NOT_CLOSE "Error\nMap non fermée (fuite détectée)\n"
# define ERR_MAP_BAD "Error\nDes caractères trouvés après des lignes vides suivant la carte.\n"
# define ERR_MAP_POS "Error\nPosition de la map incorrecte (pas toutes les textures/couleurs lues).\n"
# define ERR_MAP_ADD "Error\nDes données supp après la carte.\n"
//test

typedef struct s_config
{
	char		*no_textures;
	char		*so_textures;
	char		*we_textures;
	char		*ea_textures;
	int			color_sol[3];
	int			color_plafond[3];
} t_config;


typedef enum e_parse_state 
{
    READING_CONFIG,
    READING_MAP,
    MAP_DONE
}   t_parse_state;

typedef struct s_mapinfo
{
    char  **map2d;
    bool  **visited;
    int    width;
    int    height;
}   t_mapinfo;

typedef struct s_player_data
{
	int		*count;
	int		*row;
	int		*col;
	t_mapinfo *info;
}	t_player_data;

typedef struct s_game
{
	void		*mlx;
	void		*win;
	char		**map;
	t_config	config;
} t_game;

typedef struct s_cleanup_state
{
    bool game_cleaned;
    bool parser_cleaned;
} t_cleanup_state;
/* Structure pour regrouper les variables de parsing */
typedef struct s_parser
{
    int         fd;
    char        *line;
    char        *clean_line;
    char        *trimmed;
    int         match_text;
    int         match_color;
    bool        map_started;
    bool        map_is_done;
    bool        empty_line_after_map;
	t_game		*game;
	t_cleanup_state *state;
} t_parser;



int				close_window(t_game *game);
int				key_press(int keycode, t_game *game);
void 			init_config_game(t_game *game);
int				ft_parse(t_game *game ,char *filename);
void	parse_color(t_game *game, char *clean_line, char *color_str, t_parser *parser);
void 			ft_split_three(t_game *game, char *clean_line, char *trimed);
void 			append_map_line(t_game *game, char *clean_line);
void			check_validate_map(t_game *game, t_parser *parser);
void			free_split(char **tokens);
int				is_integer(char *str);
void			error_and_exit(char *msg);
void			error_and_exit_free(char **tokens, char *msg);
void	check_color_value(int value, t_parser *parser);
void	check_access(t_parser *parser);
void 			final_check_config(t_game *game);


/* Fonctions de parsing */ 
void	init_parser(t_parser *parser, t_game *game);
int     open_map_file(char *file_name);
void    process_texture_line(t_game *game, t_parser *parser);
void    process_color_line(t_game *game, t_parser *parser);
void    process_map_line(t_game *game, t_parser *parser);
void    handle_empty_line(t_parser *parser);
void    check_map_errors(t_parser *parser);
//void    cleanup_parser_resources(t_parser *parser, int fd);
void	assign_texture(t_game *game, t_parser *parser);
void	assign_if_not_defined(char **texture_field, char *trimmed,
	char *error_msg, t_parser *parser);
bool	is_only_spaces(char *line);
void	check_first_or_last_line(char *line, t_parser *parser);
void	check_middle_line(char *line, int row, t_parser *parser);
void	check_line_borders( char *line, int row, int first, int last, t_parser *parser);
bool	dfs_closed(t_mapinfo *info, int r, int c);
bool	is_valid_map_char(char c);
void	exit_text_with_error(char *msg, t_parser *parser);

void	init_visited_map(t_mapinfo *info);
void	free_mapinfo(t_mapinfo *info);
int	get_map_height(char **map);
void	check_map_empty(int height);
int	get_max_width(char **map, int height);

void	init_mapinfo_struct(t_mapinfo *info, char **map, int h, int w);
void	copy_and_pad_line(char *dest, char *src, int width);

void free_map(char **map);
void free_config(t_config *config);
void cleanup_all(t_game *game, t_parser *parser);
void cleanup_before_exit(t_game *game);
void cleanup_parser_resources(t_parser *parser);
void cleanup_get_next_line(void);


#endif

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   append_map.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:23 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 15:28:50 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static int	count_lines(char **map)
{
	int	cnt;

	cnt = 0;
	while (map && map[cnt])
		cnt++;
	return (cnt);
}

static char	**alloc_and_copy(char **old_map, int count)
{
	int		i;
	char	**new_map;

	new_map = malloc(sizeof(char *) * (count + 2));
	if (!new_map)
	{
		ft_putstr_fd(ERR_MAP_MALLOC, 2);
		exit(EXIT_FAILURE);
	}
	i = 0;
	while (old_map && old_map[i])
	{
		new_map[i] = old_map[i];
		i++;
	}
	new_map[i] = NULL;
	if (old_map)
		free(old_map);
	return (new_map);
}

void	append_map_line(t_game *game, char *cpy_line)
{
	int		count;
	char	**new_map;

	count = count_lines(game->map);
	new_map = alloc_and_copy(game->map, count);
	new_map[count] = cpy_line;
	new_map[count + 1] = NULL;
	// if (game->map)
	// 	free(game->map);
	game->map = new_map;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help1.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:35 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 15:45:32 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

bool	is_only_spaces(char *line)
{
	int	i;

	i = 0;
	while (line[i])
	{
		if (line[i] != ' ' && line[i] != '\t')
			return (false);
		i++;
	}
	return (true);
}

void	check_first_or_last_line(char *line, t_parser *parser)
{
	int	i;

	i = 0;
	while (line[i] == ' ' || line[i] == '\t')
		i++;
	while (line[i] != '\0')
	{
		while (line[i] != '\0' && line[i] != ' ' && line[i] != '\t')
		{
			if (line[i] != '1')
				exit_text_with_error(ERR_MAP_FIRST_LAST_LINE, parser);
			i++;
		}
		while (line[i] == ' ' || line[i] == '\t')
			i++;
	}
}

void	check_line_borders(char *line, int row, int first, int last, t_parser *parser)
{
	if (is_only_spaces(line))
	{
		ft_putstr_fd("Error\nLigne : ", 2);
		ft_putnbr_fd(row, 2);
		ft_putstr_fd(" vide ou que des espaces.\n", 2);
		exit_text_with_error("", parser);
	}
	if (row == first || row == last)
		check_first_or_last_line(line, parser);
	else
		check_middle_line(line, row, parser);
}

bool	dfs_closed(t_mapinfo *info, int r, int c)
{
	if (r < 0 || r >= info->height || c < 0 || c >= info->width)
		return (false);
	if (info->visited[r][c] || info->map2d[r][c] == '1')
		return (true);
	info->visited[r][c] = true;
	if (!dfs_closed(info, r - 1, c))
		return (false);
	if (!dfs_closed(info, r + 1, c))
		return (false);
	if (!dfs_closed(info, r, c - 1))
		return (false);
	if (!dfs_closed(info, r, c + 1))
		return (false);
	return (true);
}

bool	is_valid_map_char(char c)
{
	return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W'
		|| c == ' ');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:37:02 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/07 20:49:46 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	init_visited_map(t_mapinfo *info)
{
	int	r;

	info->visited = malloc(sizeof(bool *) * info->height);
	if (!info->visited)
		error_and_exit(ERR_MAP_MALLOC);
	r = 0;
	while (r < info->height)
	{
		info->visited[r] = calloc(info->width, sizeof(bool));
		if (!info->visited[r])
			error_and_exit(ERR_MAP_MALLOC);
		r++;
	}
}

void	free_mapinfo(t_mapinfo *info)
{
	int	r;

	r = 0;
	while (r < info->height)
	{
		free(info->map2d[r]);
		free(info->visited[r]);
		r++;
	}
	free(info->map2d);
	free(info->visited);
}

int	get_map_height(char **map)
{
	int	height;

	height = 0;
	while (map[height])
		height++;
	return (height);
}

void	check_map_empty(int height)
{
	if (height == 0)
	{
		ft_putstr_fd(ERR_MAP_EMPTY, 2);
		exit(EXIT_FAILURE);
	}
}

int	get_max_width(char **map, int height)
{
	int	i;
	int	len;
	int	width;

	width = 0;
	i = 0;
	while (i < height)
	{
		len = (int)ft_strlen(map[i]);
		if (len > width)
			width = len;
		i++;
	}
	return (width);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:35 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 15:47:08 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	print_line_error_empty(int row, t_parser *parser)
{
	ft_putstr_fd("Error\nLigne : ", 2);
	ft_putnbr_fd(row, 2);
	ft_putstr_fd(" est vide.\n", 2);
	exit_text_with_error("", parser);
}

static void	print_line_error_end(int row, t_parser *parser)
{
	ft_putstr_fd("Error\nLigne : ", 2);
	ft_putnbr_fd(row, 2);
	ft_putstr_fd(" ne finit pas par un mur '1'.\n", 2);
	exit_text_with_error("", parser);
}

static void	check_line_starts_with_wall(char *line, t_parser *parser)
{
	int	i;

	i = 0;
	while (line[i] == ' ' || line[i] == '\t')
		i++;
	if (line[i] != '1')
		exit_text_with_error(ERR_MAP_START_LINE, parser);
}

static void	check_line_ends_with_wall(char *line, int row, t_parser *parser)
{
	int	end;

	end = (int)strlen(line) - 1;
	while (end >= 0 && (line[end] == ' ' || line[end] == '\t'))
		end--;
	if (end < 0)
		print_line_error_empty(row, parser);
	if (line[end] != '1')
		print_line_error_end(row, parser);
}

void	check_middle_line(char *line, int row, t_parser *parser)
{
	check_line_starts_with_wall(line, parser);
	check_line_ends_with_wall(line, row, parser);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_valid_map.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:41 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 15:42:44 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	check_map_borders(char **map, int height, t_parser *parser)
{
	int	row;
	int	last;

	row = 0;
	last = height - 1;
	while (row < height)
	{
		check_line_borders(map[row], row, 0, last, parser);
		row++;
	}
}

static void	check_and_store_player(char ch, int r, int c, t_player_data data)
{
	if (!is_valid_map_char(ch))
		error_and_exit(ERR_MAP_INVALID_CHAR);
	if (ch == 'N' || ch == 'S' || ch == 'E' || ch == 'W')
	{
		(*data.count)++;
		*data.row = r;
		*data.col = c;
		data.info->map2d[r][c] = '0';
	}
}

static void	validate_and_get_player(t_mapinfo *info, int *pr, int *pc)
{
	int				r;
	int				c;
	int				player_count;
	char			ch;
	t_player_data	data;

	player_count = 0;
	data.count = &player_count;
	data.row = pr;
	data.col = pc;
	data.info = info;
	r = 0;
	while (r < info->height)
	{
		c = 0;
		while (c < info->width)
		{
			ch = info->map2d[r][c];
			check_and_store_player(ch, r, c, data);
			c++;
		}
		r++;
	}
	if (player_count != 1)
		error_and_exit(ERR_MAP_TEXT_MORE_THAN_ONE);
}

void	check_validate_map(t_game *game, t_parser *parser)
{
	t_mapinfo	info;
	int			player_r;
	int			player_c;
	int			height;
	int			width;

	height = get_map_height(game->map);
	check_map_empty(height);
	check_map_borders(game->map, height, parser);
	width = get_max_width(game->map, height);
	init_mapinfo_struct(&info, game->map, height, width);
	validate_and_get_player(&info, &player_r, &player_c);
	init_visited_map(&info);
	if (!dfs_closed(&info, player_r, player_c))
		error_and_exit(ERR_MAP_NOT_CLOSE);
	free_mapinfo(&info);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:48 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/07 20:08:32 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	close_window(t_game *game)
{
	mlx_destroy_window(game->mlx, game->win);
	mlx_destroy_display(game->mlx);
	free(game->mlx);
	exit(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:51:00 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	exit_text_with_error(char *msg, t_parser *parser)
{
	ft_putstr_fd(msg, 2);
    cleanup_all(parser->game, parser);
    exit(EXIT_FAILURE);
}

void	error_and_exit(char *msg)
{
	ft_putstr_fd(msg, 2);
	exit(EXIT_FAILURE);
}

void	error_and_exit_free(char **tokens, char *msg)
{
	free_split(tokens);
	ft_putstr_fd(msg, 2);
	exit(EXIT_FAILURE);
}

void	check_color_value(int value, t_parser *parser)
{
	if (value < 0 || value > 255)
	{
		ft_putstr_fd("Error:\nCouleur invalide: ", 2);
		ft_putnbr_fd(value, 2);
		ft_putchar_fd('\n', 2);
		exit_text_with_error("", parser);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   final_check.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 20:19:21 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/07 20:21:46 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	check_textures(t_game *game)
{
	if (!game->config.no_textures)
		error_and_exit(ERR_TEXTURE_NOT_DEFINED_NO);
	if (!game->config.so_textures)
		error_and_exit(ERR_TEXTURE_NOT_DEFINED_SO);
	if (!game->config.ea_textures)
		error_and_exit(ERR_TEXTURE_NOT_DEFINED_EA);
	if (!game->config.we_textures)
		error_and_exit(ERR_TEXTURE_NOT_DEFINED_WE);
}

static void	check_colors(t_game *game)
{
	if (game->config.color_sol[0] == -1)
		error_and_exit(ERR_COLOR_NOT_DEFINED_F);
	if (game->config.color_plafond[0] == -1)
		error_and_exit(ERR_COLOR_NOT_DEFINED_C);
}

static void	check_map_presence(t_game *game)
{
	if (!game->map)
		error_and_exit(ERR_MAP_NOT_DEFINED);
}

void	final_check_config(t_game *game)
{
	if (!game)
		return ;
	check_textures(game);
	check_colors(game);
	check_map_presence(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:56 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:52:46 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	free_split(char **tokens)
{
	int	i;

	i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}

void cleanup_parser_resources(t_parser *parser)
{
    if (!parser)
        return;
        
    if (parser->line)
    {
        free(parser->line);
        parser->line = NULL;
    }
    if (parser->clean_line)
    {
        free(parser->clean_line);
        parser->clean_line = NULL;
    }
    if (parser->trimmed)
    {
        free(parser->trimmed);
        parser->trimmed = NULL;
    }
}

void free_map(char **map)
{
    int	i;
	
	i = 0;
    if (!map)
        return;
    while (map[i])
    {
        free(map[i]);
        i++;
    }
    free(map);
}

void free_config(t_config *config)
{
	if(!config)
		return;
    if (config->no_textures)
        free(config->no_textures);
    if (config->so_textures)
        free(config->so_textures);
    if (config->we_textures)
        free(config->we_textures);
    if (config->ea_textures)
	{

        free(config->ea_textures);
	}
	config->no_textures = NULL;
	config->so_textures = NULL;
	config->we_textures = NULL;
	config->ea_textures = NULL;
}



void cleanup_all(t_game *game, t_parser *parser)
{
	if (game && parser && parser->state && !parser->state->game_cleaned)
	{
		parser->state->game_cleaned = true;
		free_config(&game->config);
		if (game->map)
		{
			free_map(game->map);
			game->map = NULL;
		}
	}
	if (parser && parser->state && !parser->state->parser_cleaned)
	{
		parser->state->parser_cleaned = true;
		cleanup_parser_resources(parser);
	}
	if (parser && parser->state)
	{
		free(parser->state);
		parser->state = NULL;
	}
}

void cleanup_before_exit(t_game *game)
{
    free_config(&game->config);
    free_map(game->map);
    if (game->mlx)
    {
        if (game->win)
            mlx_destroy_window(game->mlx, game->win);
    }
}

void cleanup_get_next_line(void)
{
	get_next_line(-42);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:59 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:43:26 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	copy_and_pad_line(char *dest, char *src, int width)
{
	int	len;
	int	c;

	len = (int)ft_strlen(src);
	c = 0;
	while (c < len)
	{
		dest[c] = src[c];
		c++;
	}
	while (c < width)
	{
		dest[c] = ' ';
		c++;
	}
	dest[width] = '\0';
}

void	init_mapinfo_struct(t_mapinfo *info, char **map, int h, int w)
{
	int	r;

	info->height = h;
	info->width = w;
	info->map2d = malloc(sizeof(char *) * h);
	if (!info->map2d)
		error_and_exit(ERR_MAP_MALLOC);
	r = 0;
	while (r < h)
	{
		info->map2d[r] = malloc(sizeof(char) * (w + 1));
		if (!info->map2d[r])
			error_and_exit(ERR_MAP_MALLOC);
		copy_and_pad_line(info->map2d[r], map[r], w);
		r++;
	}
}

void	init_config_game(t_game *game)
{
	game->mlx = NULL;
	game->win = NULL;
	game->config.no_textures = NULL;
	game->config.so_textures = NULL;
	game->config.we_textures = NULL;
	game->config.ea_textures = NULL;
	game->config.color_sol[0] = -1;
	game->config.color_plafond[0] = -1;
	game->map = NULL;
}

void	init_parser(t_parser *parser, t_game *game)
{
	parser->match_text = 0;
	parser->match_color = 0;
	parser->map_started = false;
	parser->map_is_done = false;
	parser->empty_line_after_map = false;
	parser->line = NULL;
	parser->clean_line = NULL;
	parser->trimmed = NULL;
	parser->game = game;
	parser->state = malloc(sizeof(t_cleanup_state));
	if (parser->state)
	{
		parser->state->game_cleaned = false;
		parser->state->parser_cleaned = false;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   key.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:19:25 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/07 19:19:40 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	key_press(int keycode, t_game *game)
{
	printf("Touche appuyée : %d\n", keycode);
	if (keycode == 65307)
		close_window(game);
	else if (keycode == 65361)
		printf("Touche fleche gauche pressée\n");
	else if (keycode == 65363)
		printf("Touche fleche droite pressée\n");
	else if (keycode == 65362)
		printf("Touche fleche haut pressée\n");
	else if (keycode == 65364)
		printf("Touche fleche bas pressée\n");
	else if (keycode == 97)
		printf("Touche touche A(gauche) pressée\n");
	else if (keycode == 100)
		printf("Touche touche D(droit) pressée\n");
	else if (keycode == 119)
		printf("Touche touche W(haut) pressée\n");
	else if (keycode == 115)
		printf("Touche touche S(bas) pressée\n");
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:05 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/07 19:24:07 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	print_debug(t_game *game)
{
	int	i;

	i = 0;
	printf("---------- Debug Configuration ----------\n");
	printf("Textures :\n");
	printf("  NO: %s\n", game->config.no_textures);
	printf("  SO: %s\n", game->config.so_textures);
	printf("  WE: %s\n", game->config.we_textures);
	printf("  EA: %s\n", game->config.ea_textures);
	printf("Couleurs :\n");
	printf("  Sol      : %d, %d, %d\n", game->config.color_sol[0],
		game->config.color_sol[1], game->config.color_sol[2]);
	printf("  Plafond  : %d, %d, %d\n", game->config.color_plafond[0],
		game->config.color_plafond[1], game->config.color_plafond[2]);
	printf("-----------------------------------------\n");
	printf("-------map--------\n");
	while (game->map[i])
	{
		printf("%s\n", game->map[i]);
		i++;
	}
	printf("-----------------------------------------\n");
}

int	main(int ac, char **av)
{
	t_game	game;

	if (ac != 2)
	{
		printf("Usage: ./cub3d map.cub\n");
		return (EXIT_FAILURE);
	}
	init_config_game(&game);
	if (ft_parse(&game, av[1]))
		return (1);
	print_debug(&game);
	// game.mlx = mlx_init();
	// if (!game.mlx)
	// {
	// 	printf("Erreur : Init mlx\n");
	// 	return (1);
	// }
	// game.win = mlx_new_window(game.mlx, 800, 600, "Cube3D");
	// if (!game.win)
	// {
	// 	printf("Erreur : new_window\n");
	// 	mlx_destroy_display(game.mlx);
	// 	free(game.mlx);
	// 	return (1);
	// }
	// mlx_hook(game.win, 17, 0, close_window, &game);
	// mlx_hook(game.win, 2, 1L<<0, key_press, &game);
	// mlx_loop(game.mlx);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:30 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 20:22:36 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	open_map_file(char *file_name)
{
	int	fd;

	fd = open(file_name, O_RDONLY);
	if (fd == -1)
	{
		ft_putstr_fd(ERR_OPEN_FILE, 2);
		ft_putstr_fd(file_name, 2);
		ft_putstr_fd("\n", 2);
	}
	return (fd);
}

void	process_line(t_game *game, t_parser *parser)
{
	if (!parser->clean_line || ft_strlen(parser->clean_line) == 0)
	{
		handle_empty_line(parser);
		return ;
	}
	if (ft_strlen(parser->clean_line) > 0 && (!ft_strncmp(parser->clean_line,
				"NO ", 3) || !ft_strncmp(parser->clean_line, "SO ", 3)
			|| !ft_strncmp(parser->clean_line, "WE ", 3)
			|| !ft_strncmp(parser->clean_line, "EA ", 3)))
	{
		process_texture_line(game, parser);
	}
	else if (ft_strlen(parser->clean_line) > 0
		&& (!ft_strncmp(parser->clean_line, "F ", 2)
			|| !ft_strncmp(parser->clean_line, "C ", 2)))
	{
		process_color_line(game, parser);
	}
	else
		process_map_line(game, parser);
}

static void	parse_loop(t_game *game, t_parser *parser, int fd)
{
	parser->line = get_next_line(fd);
	if (!parser->line)
	{
		ft_putstr_fd(ERR_MAP_EMPTY, 2);
		close(fd);
		cleanup_get_next_line();
		exit(EXIT_FAILURE);
	}
	while (parser->line)
	{
		parser->clean_line = ft_strtrim(parser->line, " \t\n");
		process_line(game, parser);
		if (parser->clean_line)
		{
			free(parser->clean_line);
			parser->clean_line = NULL;
		}
		free(parser->line);
		parser->line = NULL;
		parser->line = get_next_line(fd);
	}
	cleanup_get_next_line();
}

int	ft_parse(t_game *game, char *file_name)
{
	t_parser	parser;
	int			fd;
	int 		result;

	init_parser(&parser, game);
	game->map = NULL;
	fd = open_map_file(file_name);
	if (fd == -1)
	{
		cleanup_get_next_line();
		return (EXIT_FAILURE);
	}
	parse_loop(game, &parser, fd);
	
	result = 0;
	if (game->map)
	{
		check_validate_map(game, &parser);
		final_check_config(game);
	}
	else
	{
		ft_putstr_fd(ERR_MAP_NOT_DEFINED, 2);
		result = 1;
	}
	close(fd);
	cleanup_get_next_line();
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_color.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:12 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 16:38:43 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static char	**split_and_validate_color(char *str)
{
	char	**tokens;
	int		count;
	int		i;

	tokens = ft_split(str, ',');
	if (!tokens)
		error_and_exit(ERR_MEM_ALLOC_COLOR);
	count = 0;
	while (tokens[count])
		count++;
	if (count != 3)
		error_and_exit_free(tokens, ERR_INVALID_COLOR_FORMAT);
	i = 0;
	while (i < 3)
	{
		if (!tokens[i])
			error_and_exit_free(tokens, "Error\nFormat de couleur invalide\n");
		i++;
	}
	return (tokens);
}

static void	assign_color(int *target, char **tokens, t_parser *parser)
{
	int	i;

	if (target[0] != -1)
		error_and_exit_free(tokens, "Error\nCouleur déjà définie.\n");
	i = 0;
	while (i < 3)
	{
		target[i] = ft_atoi(tokens[i]);
		check_color_value(target[i], parser);
		i++;
	}
}

void	parse_color(t_game *game, char *clean_line, char *color_str, t_parser *parser)
{
	char	**tokens;

	tokens = split_and_validate_color(color_str);
	if (!ft_strncmp(clean_line, "F ", 2))
		assign_color(game->config.color_sol, tokens, parser);
	else if (!ft_strncmp(clean_line, "C ", 2))
		assign_color(game->config.color_plafond, tokens, parser);
	else
	{
		free_split(tokens);
		error_and_exit(ERR_UNKNOWN_COLOR_IDENTIFIER);
	}
	free_split(tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:16 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:53:05 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	is_integer(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

void	check_access(t_parser *parser)
{
	int	fd;
	char *trimmed;

	trimmed = parser->trimmed;
	fd = open(trimmed, O_RDONLY);
	if (fd == -1 || ft_strcmp(trimmed + ft_strlen(trimmed) - 4, ".xpm"))
	{
		ft_putstr_fd("Error\nfichier de texture inaccessible: ", 2);
		ft_putstr_fd(trimmed, 2);
		cleanup_all(parser->game, parser);
		close(fd);
		exit(EXIT_FAILURE);
	}
	close(fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:55:05 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	assign_if_not_defined(char **texture_field, char *trimmed,
	char *error_msg, t_parser *parser)
{
	if (*texture_field != NULL)
	{
		ft_putstr_fd(error_msg, 2);
		free(*texture_field);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	*texture_field = ft_strdup(trimmed);
	if (*texture_field == NULL)
		exit_text_with_error(error_msg, parser);
}

void	process_map_line(t_game *game, t_parser *parser)
{
	if (ft_strlen(parser->clean_line) == 0)
	{
		handle_empty_line(parser);
		return ;
	}
	check_map_errors(parser);
	parser->map_started = true;
	append_map_line(game, ft_strtrim(parser->line, "\n"));
}

void	handle_empty_line(t_parser *parser)
{
	if (parser->map_started)
	{
		parser->map_is_done = true;
		parser->empty_line_after_map = true;
	}
}

void	check_map_errors(t_parser *parser)
{
	if (parser->map_is_done)
	{
		ft_putstr_fd(ERR_MAP_ADD, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	if (parser->empty_line_after_map)
	{
		ft_putstr_fd(ERR_MAP_BAD, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	if (!parser->match_text || !parser->match_color)
	{
		ft_putstr_fd(ERR_MAP_POS, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_text.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:26 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/07 21:46:09 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	assign_no(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.no_textures, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_NO, parser);
}

static void	assign_so(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.so_textures, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_SO, parser);
}

static void	assign_we(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.we_textures, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_WE, parser);
}

static void	assign_ea(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.ea_textures, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_EA, parser);
}

void	assign_texture(t_game *game, t_parser *parser)
{
	if (!ft_strncmp(parser->clean_line, "NO ", 3))
		assign_no(game, parser);
	else if (!ft_strncmp(parser->clean_line, "SO ", 3))
		assign_so(game, parser);
	else if (!ft_strncmp(parser->clean_line, "WE ", 3))
		assign_we(game, parser);
	else if (!ft_strncmp(parser->clean_line, "EA ", 3))
		assign_ea(game, parser);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_color.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:34 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:53:37 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	process_color_line(t_game *game, t_parser *parser)
{
	parser->match_color = 1;
	if (parser->clean_line[0] == 'F')
		parser->trimmed = ft_strtrim(parser->clean_line + 2, " \t\n");
	else if (parser->clean_line[0] == 'C')
		parser->trimmed = ft_strtrim(parser->clean_line + 2, " \t\n");
	if (!parser->trimmed)
	{
		ft_putstr_fd(ERR_MEM_ALLOC_COLOR, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	parse_color(game, parser->clean_line, parser->trimmed, parser);
	printf("Couleur lue: %s\n", parser->trimmed);
	free(parser->trimmed);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_text.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:37 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/08 22:53:51 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	trim_texture_path(t_parser *parser)
{
	if (parser->clean_line[0] == 'N' && parser->clean_line[1] == 'O')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'S' && parser->clean_line[1] == 'O')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'W' && parser->clean_line[1] == 'E')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'E' && parser->clean_line[1] == 'A')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
}

static void	check_trimmed_not_null(t_parser *parser)
{
	if (parser->trimmed == NULL)
	{
		ft_putstr_fd(ERR_MEM_ALLOC_TEXTURE, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

static void	check_trimmed_not_empty(t_parser *parser)
{
	if (ft_strlen(parser->trimmed) == 0)
	{
		ft_putstr_fd(ERR_EMPTY_TEXTURE_PATH, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

void	process_texture_line(t_game *game, t_parser *parser)
{
	parser->match_text = 1;
	trim_texture_path(parser);
	check_trimmed_not_null(parser);
	check_trimmed_not_empty(parser);
	check_access(parser);
	assign_texture(game, parser);
	free(parser->trimmed);
}
