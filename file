/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   file                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 09:33:13 by mbendidi          #+#    #+#             */
/*   Updated: 2025/06/23 12:09:21 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CUB3D_H
# define CUB3D_H

/* ============================= INCLUDES ============================== */
# include "../minilibx-linux/mlx.h"
# include "parser_cub3d.h"
# include <math.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>

/* ============================ CONSTANTES ============================= */
/* Dimensions de la fenêtre et du buffer */
# define WIDTH            800
# define HEIGHT           600
# define IMG_W            800
# define IMG_H            600

/* Taille d'un bloc (map) et décalage collision */
# define BLOCK            64
# define COLLIDE_OFFSET   5.0f

/* Nombre de textures (NO, SO, WE, EA) */
# define NBR_TEX          4

/* Identifiants de direction pour les textures */
# define NORTH            0
# define SOUTH            1
# define WEST             2
# define EAST             3

/* Vitesse de déplacement et de rotation du joueur */
# define MOVE_SPEED       1.0f
# define ROT_SPEED        0.01f

/* Codes de touches clavier (ASCII ou X11) */
# define W                119
# define S                115
# define A                97
# define D                100
# define LEFT             65361
# define RIGHT            65363

/* Autres touches */
# define KEY_Q            113
# define KEY_ESC          65307

/* Constantes mathématiques */
# define PI               3.14159265359f
# define FOV_ANGLE_DEG    60.0f          /* Champ de vision en degrés      */
# define FOV_ANGLE_RAD    1.0471975512f  /* = 60° × PI / 180                */

/* Active ou non le mode debug (affiche slices brutes, etc.) */
# define DEBUG            0

/* ============================= STRUCTURES ============================ */

/**
 * @brief Contient l’image MLX et son buffer de pixels.
 *
 * - img       : pointeur vers l’image MLX.
 * - pixels    : tableau dynamique (int *) pointant sur les pixels.
 * - bpp       : bits par pixel.
 * - size_line : nombre d’int par ligne d’image.
 * - endian    : endianess (non utilisé explicitement).
 */
typedef struct s_data_img
{
	void	*img;
	int		*pixels;
	int		bpp;
	int		size_line;
	int		endian;
}			t_data_img;

/**
 * @brief Représente l’état du joueur.
 *
 * - x, y         : position (float) au centre du bloc.
 * - angle        : orientation en radians.
 * - key_up, key_down, key_left, key_right : flags de mouvement.
 * - left_rotate, right_rotate            : flags de rotation.
 */
typedef struct s_player
{
	float	x;
	float	y;
	float	angle;
	bool	key_up;
	bool	key_down;
	bool	key_left;
	bool	key_right;
	bool	left_rotate;
	bool	right_rotate;
}			t_player;

/**
 * @brief Stocke les chemins des textures et les couleurs (RGB).
 *
 * - no_texture, so_texture, we_texture, ea_texture : chemins XPM.
 * - floor_color[3], ceiling_color[3]            : valeurs R/G/B entre 0 et 255.
 */
typedef struct s_config
{
	char	*no_texture;
	char	*so_texture;
	char	*we_texture;
	char	*ea_texture;
	int		floor_color[3];
	int		ceiling_color[3];
}			t_config;

/**
 * @brief Contient les informations d’une texture MLX.
 *
 * - img       : pointeur vers l’image chargée.
 * - pixels    : tableau dynamique (int *) pointant sur les pixels.
 * - width     : largeur de la texture (int).
 * - height    : hauteur de la texture (int).
 * - bpp       : bits par pixel.
 * - size_line : nombre d’int par ligne de la texture.
 * - endian    : endianess de la texture (X11).
 */
typedef struct s_tex
{
	void	*img;
	int		*pixels;
	int		width;
	int		height;
	int		bpp;
	int		size_line;
	int		endian;
}			t_tex;

/**
 * @brief Structure pour le calcul DDA du raycasting.
 *
 * - map_x, map_y    : indices de la case courante dans la map.
 * - rdx, rdy        : vecteur direction du rayon (cosθ, sinθ).
 * - ddx, ddy        : distance d'exclusion sur x, y (|1/rdx|, |1/rdy|).
 * - sdx, sdy        : distance à parcourir jusqu'au premier mur (step initial).
 * - sx, sy          : direction du pas sur x ou y (-1 ou +1).
 * - side            : 0 = mur vertical (axe x), 1 = mur horizontal (axe y).
 */
typedef struct s_ray
{
	int		map_x;
	int		map_y;
	float	rdx;
	float	rdy;
	float	ddx;
	float	ddy;
	float	sdx;
	float	sdy;
	int		sx;
	int		sy;
	int		side;
}			t_ray;

/**
 * @brief Décrit une tranche verticale à dessiner pour un mur.
 *
 * - x     : abscisse (colonne pixel) à l'écran.
 * - start : ordonnée (ligne pixel) de début.
 * - end   : ordonnée (ligne pixel) de fin.
 * - tex_x : coordonnée X dans la texture pour la slice.
 */
typedef struct s_vline
{
	int	x;
	int	start;
	int	end;
	int	tex_x;
}			t_vline;

/**
 * @brief Structure principale du jeu.
 *
 * - mlx      : contexte MLX (mlx_init).
 * - win      : pointeur de la fenêtre (mlx_new_window).
 * - map      : tableau de chaînes représentant la carte 
 * 		(char **, chaînes null-terminated).
 * - config   : configuration (textures + couleurs).
 * - player   : données du joueur (position, angle, flags).
 * - data_img : buffer d’image (MLX) pour dessiner pixel par pixel.
 * - textures : tableau de NBR_TEX textures chargées (XPM).
 */
typedef struct s_game
{
	void		*mlx;
	void		*win;
	char		**map;
	t_config	config;
	t_player	player;
	t_data_img	data_img;
	t_tex		textures[NBR_TEX];
}			t_game;

/*
** --------------------------------------------------------------------------
**   INITIALISATION & BOUCLE PRINCIPALE
** --------------------------------------------------------------------------
*/

int			start_mlx(t_game *game);
t_player	get_coord(t_game *game);

/*
** --------------------------------------------------------------------------
**   GESTION DU JOUEUR & INPUT
** --------------------------------------------------------------------------
*/

void		init_player(t_player *player);
int			key_press(int keycode, t_game *game);
int			key_release(int keycode, t_game *game);
void		move_player(t_player *player, t_game *game);

/*
** --------------------------------------------------------------------------
**   GRAPHISME 2D
** --------------------------------------------------------------------------
*/

void		put_pixel(int x, int y, int color, t_game *game);
void		clear_image(t_game *game);

/*
** --------------------------------------------------------------------------
**   MINI-MAP
** --------------------------------------------------------------------------
*/

void		draw_square(int x, int y, int color, t_game *game);
void		draw_map(t_game *game);

/*
** --------------------------------------------------------------------------
**   RAYCASTING & RENDU 3D
** --------------------------------------------------------------------------
*/

void		cast_ray(t_player *p, float ray_ang, t_game *g, float out[2]);
void		draw_line(t_player *p, t_game *g, float ray_ang, int x);
int			draw_loop(t_game *g);
bool		is_wall_point(float px, float py, t_game *game);
bool		is_wall(float px, float py, t_game *game);

/*
** --------------------------------------------------------------------------
**   CHARGEMENT DES TEXTURES
** --------------------------------------------------------------------------
*/

void		text_load(t_game *game);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_cub3d.h                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 09:33:09 by mbendidi          #+#    #+#             */
/*   Updated: 2025/06/23 12:05:57 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSER_CUB3D_H
# define PARSER_CUB3D_H

# include <fcntl.h>
# include <libft.h>
# include <mlx.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

/* ===================== CONSTANTES ERREURS ===================== */

# define ERR_OPEN_FILE \
	"Error\nImpossible d'ouvrir le fichier: "
# define ERR_MEM_ALLOC_TEXTURE \
	"Error\nÉchec de l'allocation mémoire pour textures.\n"
# define ERR_EMPTY_TEXTURE_PATH \
	"Error\nChemin de texture vide.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_NO \
	"Error\nTexture NO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_SO \
	"Error\nTexture SO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_WE \
	"Error\nTexture WE déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_EA \
	"Error\nTexture EA déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_NO \
	"Error\nÉchec de l'allocation mémoire pour texture NO.\n"
# define ERR_MEM_ALLOC_TEXTURE_SO \
	"Error\nÉchec de l'allocation mémoire pour texture SO.\n"
# define ERR_MEM_ALLOC_TEXTURE_WE \
	"Error\nÉchec de l'allocation mémoire pour texture WE.\n"
# define ERR_MEM_ALLOC_TEXTURE_EA \
	"Error\nÉchec de l'allocation mémoire pour texture EA.\n"
# define ERR_MEM_ALLOC_COLOR \
	"Error\nÉchec de l'allocation mémoire pour couleur.\n"
# define ERR_INVALID_COLOR_FORMAT \
	"Error\nInvalid color format (need exactly 3 values)\n"
# define ERR_INVALID_COLOR_VALUE \
	"Error\nCouleur invalide: \n"
# define ERR_UNKNOWN_COLOR_IDENTIFIER \
	"Error\nIdentifiant de couleur inconnu \n"
# define ERR_MAP_FIRST_LAST_LINE \
	"Error\nLigne (1ère/dernière) contient autre chose que '1'.\n"
# define ERR_MAP_START_LINE \
	"Error\nUne ligne ne commence pas par un mur '1'.\n"
# define ERR_TEXTURE_NOT_DEFINED_NO \
	"Error\nTexture NO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_SO \
	"Error\nTexture SO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_WE \
	"Error\nTexture WE non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_EA \
	"Error\nTexture EA non définie.\n"
# define ERR_COLOR_NOT_DEFINED_F \
	"Error\nCouleur F(Sol) non définie.\n"
# define ERR_COLOR_NOT_DEFINED_C \
	"Error\nCouleur C(Plaf.) non définie.\n"
# define ERR_MAP_NOT_DEFINED \
	"Error\nMap non définie.\n"
# define ERR_MAP_EMPTY \
	"Error\nMap vide.\n"
# define ERR_MAP_INVALID_CHAR \
	"Error\nCaractère invalide.\n"
# define ERR_MAP_TEXT_MORE_THAN_ONE \
	"Error\nIl faut exactement 1 orientation (N,S,E,W).\n"
# define ERR_MAP_MALLOC \
	"Error\nMalloc failed for visited.\n"
# define ERR_MAP_NOT_CLOSE \
	"Error\nMap non fermée (fuite détectée)\n"
# define ERR_MAP_BAD \
	"Error\nDes caractères trouvés après des lignes vides suivant la carte.\n"
# define ERR_MAP_POS \
	"Error\nPosition de la map incorrecte \
	(pas toutes les textures/couleurs lues).\n"
# define ERR_MAP_ADD \
	"Error\nDes données supp après la carte.\n"

/* ===================== STRUCTURES ===================== */

struct					s_parser;
typedef struct s_config	t_config;
typedef struct s_game	t_game;
typedef struct s_parser	t_parser;

typedef enum e_parse_state
{
	READING_CONFIG,
	READING_MAP,
	MAP_DONE
}						t_parse_state;

typedef struct s_mapinfo
{
	char				**map2d;
	bool				**visited;
	int					width;
	int					height;
}						t_mapinfo;

typedef struct s_player_data
{
	int					*count;
	int					*row;
	int					*col;
	t_mapinfo			*info;
	t_parser			*parser;
}						t_player_data;

typedef struct s_cleanup_state
{
	bool				game_cleaned;
	bool				parser_cleaned;
}						t_cleanup_state;

typedef struct s_parser
{
	int					fd;
	char				*line;
	char				*clean_line;
	char				*trimmed;
	int					match_text;
	int					match_color;
	bool				map_started;
	bool				map_is_done;
	bool				empty_line_after_map;
	t_game				*game;
	t_cleanup_state		*state;
}						t_parser;

typedef struct s_line_info
{
	int					row;
	int					first;
	int					last;
}						t_line_info;

/* ===================== FONCTIONS PRINCIPALES ===================== */

int						close_window(t_game *game);
void					init_structs(t_game *game);
int						ft_parse(t_game *game, char *filename);

/* ===================== FONCTIONS DE PARSING ===================== */

void					parse_color(t_game *game, char *clean_line,
							char *color_str, t_parser *parser);
void					ft_split_three(t_game *game, char *clean_line,
							char *trimed);
void					append_map_line(t_game *game, char *clean_line);
void					check_validate_map(t_game *game, t_parser *parser);
void					free_split(char **tokens);
int						is_integer(char *str);
void					error_exit_game(t_game *game, char *msg);
void					error_and_exit(t_parser *parser, char *msg);
void					error_and_exit_free(t_parser *parser, char **tokens,
							char *msg);
void					check_color_value(int value, t_parser *parser);
void					check_access(t_parser *parser);
void					final_check_config(t_game *game, t_parser *parser);

/* ===================== UTILITAIRES DE PARSING ===================== */

void					init_parser(t_parser *parser, t_game *game);
int						open_map_file(char *file_name);
void					process_texture_line(t_game *game, t_parser *parser);
void					process_color_line(t_game *game, t_parser *parser);
void					process_map_line(t_game *game, t_parser *parser);
void					handle_empty_line(t_parser *parser);
void					check_map_errors(t_parser *parser);
void					assign_texture(t_game *game, t_parser *parser);
void					assign_if_not_defined(char **texture_field,
							char *trimmed, char *error_msg, t_parser *parser);
bool					is_only_spaces(char *line);
void					check_first_or_last_line(char *line, t_parser *parser);
void					check_middle_line(char *line, int row,
							t_parser *parser);
void					check_line_borders(char *line, t_line_info info,
							t_parser *parser);
bool					dfs_closed(t_mapinfo *info, int r, int c);
bool					is_valid_map_char(char c);
void					exit_text_with_error(char *msg, t_parser *parser);

/* ===================== GESTION DE MAP ===================== */

void					init_visited_map(t_mapinfo *info, t_parser *parser);
void					free_mapinfo(t_mapinfo *info);
int						get_map_height(char **map);
void					check_map_empty(int height);
int						get_max_width(char **map, int height);
void					init_mapinfo_struct(t_mapinfo *info, t_game *game,
							t_parser *parser);
void					copy_and_pad_line(char *dest, char *src, int width);

/* ===================== CLEANUP ===================== */

void					free_map(char **map);
void					free_config(t_config *config);
void					cleanup_all(t_game *game, t_parser *parser);
void					cleanup_before_exit(t_game *game);
void					cleanup_parser_resources(t_parser *parser);
void					cleanup_get_next_line(void);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:48 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:24:33 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Gère la fermeture de la fenêtre MLX et termine l’application.
 *
 * - Détruit la fenêtre (mlx_destroy_window).
 * - Détruit l’affichage MLX (mlx_destroy_display).
 * - Libère le contexte `game->mlx`.
 * - Appelle `exit(0)` pour quitter immédiatement.
 *
 * @param game Pointeur vers la structure de jeu (contient contextes MLX).
 * @return int Valeur ignorée (appel à exit() en interne).
 */
int	close_window(t_game *game)
{
	mlx_destroy_window(game->mlx, game->win);
	mlx_destroy_display(game->mlx);
	free(game->mlx);
	exit(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_game.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:37:16 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:28:01 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Initialise chaque texture à NULL/0 dans le tableau de textures.
 *
 * - Parcourt `text[0]` à `text[NBR_TEX-1]` et met tous les champs à NULL ou 0.
 *
 * @param text Tableau de `t_tex` de taille NBR_TEX.
 */
static void	init_textures(t_tex text[NBR_TEX])
{
	int	i;

	i = 0;
	while (i < NBR_TEX)
	{
		text[i].img = NULL;
		text[i].pixels = NULL;
		text[i].width = 0;
		text[i].height = 0;
		text[i].bpp = 0;
		text[i].size_line = 0;
		text[i].endian = 0;
		i++;
	}
}

/**
 * @brief Réinitialise la structure `t_data_img` à des valeurs vides.
 *
 * - Met `img`, `pixels` à NULL ; `bpp`, `size_line`, `endian` à 0.
 *
 * @param data_img Pointeur vers la structure `t_data_img` à initialiser.
 */
static void	init_data_img(t_data_img *data_img)
{
	data_img->img = NULL;
	data_img->pixels = NULL;
	data_img->bpp = 0;
	data_img->size_line = 0;
	data_img->endian = 0;
}

/**
 * @brief Initialise les chemins de textures et les couleurs à
	-1 pour th Floor/ceiling.
 *
 * - Met tous les pointeurs de texture (`no_texture`, `so_texture`,
	`we_texture`, `ea_texture`) à NULL.
 * - Initialise `floor_color` et `ceiling_color` à -1 (trois composantes).
 *
 * @param config Pointeur vers la structure `t_config`.
 */
static void	init_config(t_config *config)
{
	int	i;

	config->no_texture = NULL;
	config->so_texture = NULL;
	config->we_texture = NULL;
	config->ea_texture = NULL;
	i = 0;
	while (i < 3)
	{
		config->floor_color[i] = -1;
		config->ceiling_color[i] = -1;
		i++;
	}
}

/**
 * @brief Initialise la position de départ et les flags de touches du joueur.
 *
 * - Place le joueur au centre de l’écran (`WIDTH/2`, `HEIGHT/2`),
	angle `-PI/2`.
 * - Met toutes les touches (`key_up`, `key_down`, `key_left`, ...) à false.
 *
 * @param player Pointeur vers la structure `t_player`.
 */
static void	init_player_defaults(t_player *player)
{
	player->x = WIDTH / 2;
	player->y = HEIGHT / 2;
	player->angle = -PI / 2;
	player->key_up = false;
	player->key_down = false;
	player->key_left = false;
	player->key_right = false;
	player->left_rotate = false;
	player->right_rotate = false;
}

/**
 * @brief Initialise tous les champs de `t_game` avant le parsing.
 *
 * - Réinitialise la totalité de la structure `game` à 0 (`ft_memset`).
 * - Appelle `init_data_img`, `init_config`, met `game->map = NULL`.
 * - Appelle `init_player_defaults` et `init_textures`.
 *
 * @param game Pointeur vers la structure de jeu à initialiser.
 */
void	init_structs(t_game *game)
{
	ft_memset(game, 0, sizeof(*game));
	init_data_img(&game->data_img);
	init_config(&game->config);
	game->map = NULL;
	init_player_defaults(&game->player);
	init_textures(game->textures);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:05 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:24:02 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Affiche l’utilisation du programme si 
 * le nombre d’arguments est incorrect.
 *
 * Affiche « Usage: ./cub3d <map.cub> » 
 * dans la sortie standard et retourne
 * EXIT_FAILURE.
 *
 * @return int EXIT_FAILURE toujours.
 */
static int	print_usage(void)
{
	ft_printf("Usage: ./cub3d <map.cub>\n");
	return (EXIT_FAILURE);
}

int	main(int ac, char **av)
{
	t_game	game;

	if (ac != 2)
		return (print_usage());
	init_structs(&game);
	if (ft_parse(&game, av[1]))
		return (EXIT_FAILURE);
	if (start_mlx(&game) == 0)
	{
		cleanup_before_exit(&game);
		return (EXIT_FAILURE);
	}
	cleanup_before_exit(&game);
	return (EXIT_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_mlx.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:10:47 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:29:07 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Initialise le contexte MLX (mlx_init) et vérifie la réussite.
 *
 * - Appelle `mlx_init()`.
 * - Si échec, affiche un message sur stderr et retourne -1.
 *
 * @param game Pointeur vers la structure de jeu (stockage du contexte MLX).
 * @return int 0 si succès, -1 en cas d’erreur.
 */
static int	init_mlx_ptr(t_game *game)
{
	game->mlx = mlx_init();
	if (!game->mlx)
	{
		ft_putstr_fd("Error\nInit mlx\n", 2);
		return (-1);
	}
	return (0);
}

/**
 * @brief Crée la fenêtre MLX de taille WIDTH×HEIGHT.
 *
 * - Appelle `mlx_new_window` avec le contexte MLX, WIDTH,
	HEIGHT et le titre « Cub3D ».
 * - Si échec, affiche un message sur stderr, détruit l’affichage MLX,
	libère `game->mlx`,
 *   et retourne -1.
 *
 * @param game Pointeur vers la structure de jeu (contexte MLX).
 * @return int 0 si succès, -1 en cas d’erreur.
 */
static int	init_window(t_game *game)
{
	game->win = mlx_new_window(game->mlx, WIDTH, HEIGHT, "Cub3D");
	if (!game->win)
	{
		ft_putstr_fd("Error\nnew_window\n", 2);
		mlx_destroy_display(game->mlx);
		free(game->mlx);
		return (-1);
	}
	return (0);
}

/**
 * @brief Crée l’image MLX et récupère son buffer pour accéder aux pixels.
 *
 * - Appelle `mlx_new_image` avec `game->mlx`, WIDTH et HEIGHT.
 * - Si échec, nettoie la fenêtre et l’affichage MLX, libère `game->mlx`,
	et retourne -1.
 * - Récupère le pointeur vers les pixels (`mlx_get_data_addr`) 
 	et calcule `size_line`.
 *
 * @param g Pointeur vers la structure de jeu (contexte MLX + data_img).
 * @return int 0 si succès, -1 en cas d’erreur.
 */
static int	init_image(t_game *g)
{
	char	*addr;

	g->data_img.img = mlx_new_image(g->mlx, WIDTH, HEIGHT);
	if (!g->data_img.img)
	{
		ft_putstr_fd("Error\nnew_image\n", 2);
		mlx_destroy_window(g->mlx, g->win);
		mlx_destroy_display(g->mlx);
		free(g->mlx);
		return (-1);
	}
	addr = mlx_get_data_addr(g->data_img.img, &g->data_img.bpp,
			&g->data_img.size_line, &g->data_img.endian);
	g->data_img.pixels = (int *)addr;
	g->data_img.size_line /= (g->data_img.bpp / 8);
	return (0);
}

/**
 * @brief Initialise MLX, crée la fenêtre, l’image,
	et lance la boucle graphique.
 *
 * - Appelle `init_mlx_ptr`, `init_window`, `init_image`.
 * - Place le joueur aux coordonnées initiales (`get_coord`).
 * - Charge les textures (`text_load`).
 * - Configure les hooks clavier (key_press, key_release).
 * - Configure le hook de fermeture de fenêtre (close_window).
 * - Configure la boucle principale (`mlx_loop_hook` puis `mlx_loop`).
 *
 * @param game Pointeur vers la structure de jeu.
 * @return int 1 si tout s’est bien passé, 0 ou
	-1 en cas d’erreur d’initialisation.
 */
int	start_mlx(t_game *game)
{
	if (init_mlx_ptr(game) || init_window(game) || init_image(game))
		return (-1);
	game->player = get_coord(game);
	text_load(game);
	mlx_hook(game->win, 2, 1L << 0, key_press, game);
	mlx_hook(game->win, 3, 1L << 1, key_release, game);
	mlx_hook(game->win, 17, 0, close_window, game);
	mlx_loop_hook(game->mlx, draw_loop, game);
	mlx_loop(game->mlx);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   graphics.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:49 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 18:44:13 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Place un pixel de couleur donnée dans l’image MLX.
 *
 * - Si (x,y) hors écran, ne fait rien.
 * - Sinon, calcule `index = y * size_line + x` 
 * et stocke `pixels[index] = color`.
 *
 * @param x     Abscisse du pixel en pixels.
 * @param y     Ordonnée du pixel en pixels.
 * @param color Couleur 32 bits (0xAARRGGBB ou 0x00RRGGBB).
 * @param game  Pointeur vers la structure de jeu (`t_game`).
 */
void	put_pixel(int x, int y, int color, t_game *game)
{
	int	index;

	if (x >= WIDTH || y >= HEIGHT || x < 0 || y < 0)
		return ;
	index = y * game->data_img.size_line + x;
	game->data_img.pixels[index] = color;
}

/**
 * @brief Efface l’image en noir (couleur 0x00000000).
 *
 * - Parcourt tous les pixels de 0 ≤ y < HEIGHT et 0 ≤ x < WIDTH.
 * - Appelle `put_pixel(x, y, 0x00000000, game)`.
 *
 * @param game Pointeur vers la structure de jeu (`t_game`).
 */
void	clear_image(t_game *game)
{
	int	y;
	int	x;

	y = 0;
	while (y < HEIGHT)
	{
		x = 0;
		while (x < WIDTH)
		{
			put_pixel(x, y, 0x00000000, game);
			x++;
		}
		y++;
	}
}

/**
 * @brief Dessine un carré (bord uniquement) de taille BLOCK en pixels.
 *
 * - Pour i = 0…BLOCK-1, place quatre pixels : 
 *   - (x + i, y) et (x + i, y + BLOCK) pour les bords horizontaux.
 *   - (x, y + i) et (x + BLOCK, y + i) pour les bords verticaux.
 *
 * @param x     Abscisse du coin supérieur gauche (en pixels).
 * @param y     Ordonnée du coin supérieur gauche (en pixels).
 * @param color Couleur 32 bits pour les bords.
 * @param game  Pointeur vers la structure de jeu (`t_game`).
 */
void	draw_square(int x, int y, int color, t_game *game)
{
	int	i;

	i = 0;
	while (i < BLOCK)
	{
		put_pixel(x + i, y, color, game);
		put_pixel(x + i, y + BLOCK, color, game);
		put_pixel(x, y + i, color, game);
		put_pixel(x + BLOCK, y + i, color, game);
		i++;
	}
}

/**
 * @brief Parcourt la carte et dessine un quadrillage pour les murs.
 *
 * - Pour chaque case (row,col) où `game->map[row][col] == '1'`, 
 *   appelle `draw_square(col * BLOCK, row * BLOCK, 0x0000FF, game)`.
 *
 * @param game Pointeur vers la structure de jeu (`t_game`).
 */
void	draw_map(t_game *game)
{
	int	row;
	int	col;

	row = 0;
	while (game->map[row])
	{
		col = 0;
		while (game->map[row][col])
		{
			if (game->map[row][col] == '1')
				draw_square(col * BLOCK, row * BLOCK, 0x0000FF, game);
			col++;
		}
		row++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   text.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 11:59:24 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:31:00 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Remplit le tableau `paths[]` avec les chemins de texture 
 * issus de la configuration.
 *
 * - `paths[0] = cfg->no_texture`  
 * - `paths[1] = cfg->so_texture`  
 * - `paths[2] = cfg->we_texture`  
 * - `paths[3] = cfg->ea_texture`  
 *
 * Cette fonction est appelée au début de `text_load` pour préparer la
 * liste des quatre chemins XPM à charger.
 *
 * @param paths Tableau de taille NBR_TEX (4) qui recevra 
 * les pointeurs vers les chaînes de chemins.
 * @param cfg   Pointeur vers la structure `t_config` 
 * contenant les quatre chemins (no/so/we/ea).
 */
static void	fill_paths(char *paths[NBR_TEX], t_config *cfg)
{
	paths[0] = cfg->no_texture;
	paths[1] = cfg->so_texture;
	paths[2] = cfg->we_texture;
	paths[3] = cfg->ea_texture;
}

/**
 * @brief Charge toutes les textures XPM définies dans `game->config`.
 *
 * - Récupère les chemins depuis `game->config.
 * {no,so,we,ea}_texture` dans `paths[]`.
 * - Pour chaque i ∈ [0..NBR_TEX-1] :
 *   - Vérifie `paths[i]` non-NULL et se terminant par “.xpm”.
 *   - Appelle `mlx_xpm_file_to_image` pour charger l’image.
 *   - Si échec, appelle `error_exit_game`.
 *   - Récupère `pixels`, `bpp`, `size_line`, `endian` via `mlx_get_data_addr`.
 * - Incrémente i jusqu’à NBR_TEX.
 *
 * @param game Pointeur vers la structure de jeu (`t_game`).
 */
void	text_load(t_game *game)
{
	int		i;
	char	*paths[NBR_TEX];
	char	*addr;

	i = 0;
	fill_paths(paths, &game->config);
	while (i < NBR_TEX)
	{
		if (!paths[i] || paths[i][0] == '\0')
			error_exit_game(game, "Error\nMissing texture path\n");
		if (ft_strlen(paths[i]) < 4 || ft_strcmp(paths[i] + ft_strlen(paths[i])
				- 4, ".xpm") != 0)
			error_exit_game(game, "Error\nTexture file must end with .xpm\n");
		game->textures[i].img = mlx_xpm_file_to_image(game->mlx, paths[i],
				&game->textures[i].width, &game->textures[i].height);
		if (!game->textures[i].img)
			error_exit_game(game, "Error\nCannot load texture\n");
		addr = mlx_get_data_addr(game->textures[i].img, &game->textures[i].bpp,
				&game->textures[i].size_line, &game->textures[i].endian);
		game->textures[i].pixels = (int *)addr;
		game->textures[i].size_line /= (game->textures[i].bpp / 8);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   append_map.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:23 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:49:49 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Compte le nombre de lignes actuellement 
 * dans la map (tableau de chaînes).
 *
 * @param map Tableau de chaînes (char **).
 * @return int Nombre de lignes (jusqu’au premier NULL).
 */
static int	count_lines(char **map)
{
	int	cnt;

	cnt = 0;
	while (map && map[cnt])
		cnt++;
	return (cnt);
}

/**
 * @brief Alloue un nouveau tableau `new_map` de taille (count+2) 
 * et copie `old_map`.
 *
 * - Copie chaque pointeur `old_map[i]` dans `new_map[i]`.
 * - Place `new_map[count] = NULL` puis libère `old_map`.
 * - Vérifie l’allocation : si échoue, affiche `ERR_MAP_MALLOC` 
 * 	 et `exit(EXIT_FAILURE)`.
 *
 * @param old_map Ancienne map (char **), peut être NULL.
 * @param count   Nombre de lignes dans `old_map`.
 * @return char** Nouveau tableau de chaînes, prêt à recevoir une nouvelle ligne.
 */
static char	**alloc_and_copy(char **old_map, int count)
{
	int		i;
	char	**new_map;

	new_map = malloc(sizeof(char *) * (count + 2));
	if (!new_map)
	{
		ft_putstr_fd(ERR_MAP_MALLOC, 2);
		exit(EXIT_FAILURE);
	}
	i = 0;
	while (old_map && old_map[i])
	{
		new_map[i] = old_map[i];
		i++;
	}
	new_map[i] = NULL;
	if (old_map)
		free(old_map);
	return (new_map);
}

/**
 * @brief Ajoute une ligne à la fin de `game->map`.
 *
 * - Calcule `count = count_lines(game->map)`.
 * - Alloue un nouveau tableau de taille count+2 via `alloc_and_copy`.
 * - Copie `cpy_line` dans `new_map[count]`, place NULL dans `new_map[count+1]`.
 * - Met à jour `game->map = new_map`.
 *
 * @param game     Pointeur vers la structure de jeu (`t_game`).
 * @param cpy_line Chaîne déjà allouée (with '\n' trimmé) à ajouter.
 */
void	append_map_line(t_game *game, char *cpy_line)
{
	int		count;
	char	**new_map;

	count = count_lines(game->map);
	new_map = alloc_and_copy(game->map, count);
	new_map[count] = cpy_line;
	new_map[count + 1] = NULL;
	game->map = new_map;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help1.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:35 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:23:49 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Vérifie si une ligne de la map ne contient que 
 * des espaces ou tabulations.
 *
 * - Parcourt `line[i]` tant que `line[i] == ' '` ou `'\t'`.
 * - Si rencontre un autre caractère, renvoie false.
 *
 * @param line Chaîne à tester.
 * @return bool true si uniquement espaces/tabs, false sinon.
 */
bool	is_only_spaces(char *line)
{
	int	i;

	i = 0;
	while (line[i])
	{
		if (line[i] != ' ' && line[i] != '\t')
			return (false);
		i++;
	}
	return (true);
}

/**
 * @brief Vérifie que la première ou la dernière ligne 
 * de la map est uniquement composée de '1'.
 *
 * - Parcourt `line` après avoir sauté espaces/tabs initiaux.
 * - Pour chaque groupe de caractères non-blancs, 
 * si ce n’est pas '1', 
 * appelle `exit_text_with_error(ERR_MAP_FIRST_LAST_LINE, parser)`.
 *
 * @param line   Chaîne de la ligne (map).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	check_first_or_last_line(char *line, t_parser *parser)
{
	int	i;

	i = 0;
	while (line[i] == ' ' || line[i] == '\t')
		i++;
	while (line[i] != '\0')
	{
		while (line[i] != '\0' && line[i] != ' ' && line[i] != '\t')
		{
			if (line[i] != '1')
				exit_text_with_error(ERR_MAP_FIRST_LAST_LINE, parser);
			i++;
		}
		while (line[i] == ' ' || line[i] == '\t')
			i++;
	}
}

/**
 * @brief Vérifie la bordure d’une ligne donnée (première, dernière ou middle).
 *
 * - Si `is_only_spaces(line)` : 
 *   - Affiche `"Error\nLigne : <row> vide ou que des espaces.\n"` 
 *  	puis `exit_text_with_error`.
 * - Si `row == first || row == last` : 
 * appelle `check_first_or_last_line(line, parser)`.
 * - Sinon : appelle `check_middle_line(line, row, parser)`.
 *
 * @param line   Chaîne de la ligne (map).
 * @param info   Structure `t_line_info` contenant `row`, `first`, `last`.
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	check_line_borders(char *line, t_line_info info, t_parser *parser)
{
	if (is_only_spaces(line))
	{
		ft_putstr_fd("Error\nLigne : ", 2);
		ft_putnbr_fd(info.row, 2);
		ft_putstr_fd(" vide ou que des espaces.\n", 2);
		exit_text_with_error("", parser);
	}
	if (info.row == info.first || info.row == info.last)
		check_first_or_last_line(line, parser);
	else
		check_middle_line(line, info.row, parser);
}

/**
 * @brief Effectue une recherche en profondeur 
 * pour vérifier que la map est fermée.
 *
 * - Si `(r,c)` hors bornes, renvoie false (fuite).
 * - Si `visited[r][c] == true` ou `map2d[r][c] == '1'`, 
 * 		renvoie true (mur ou déjà visité).
 * - Marque `visited[r][c] = true`.
 * - Appelle récursivement pour (r-1,c), (r+1,c), (r,c-1), (r,c+1). 
 * 		Si un appel renvoie false, retourne false.
 * - Sinon, retourne true.
 *
 * @param info Pointeur vers `t_mapinfo` 
 * (contient `map2d`, `visited`, `height`, `width`).
 * @param r    Coordonnée Y courante dans la map.
 * @param c    Coordonnée X courante dans la map.
 * @return bool true si la zone est fermée, 
 * false si une fuite détectée.
 */
bool	dfs_closed(t_mapinfo *info, int r, int c)
{
	if (r < 0 || r >= info->height || c < 0 || c >= info->width)
		return (false);
	if (info->visited[r][c] || info->map2d[r][c] == '1')
		return (true);
	info->visited[r][c] = true;
	if (!dfs_closed(info, r - 1, c))
		return (false);
	if (!dfs_closed(info, r + 1, c))
		return (false);
	if (!dfs_closed(info, r, c - 1))
		return (false);
	if (!dfs_closed(info, r, c + 1))
		return (false);
	return (true);
}

/**
 * @brief Vérifie qu’un caractère est valide pour la map (0,1,N,S,E,W ou espace).
 *
 * @param c Caractère à tester.
 * @return bool true si c ∈ {'0','1','N','S','E','W',' '}, false sinon.
 */
bool	is_valid_map_char(char c)
{
	return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W'
		|| c == ' ');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:37:02 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:01:46 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Alloue et initialise la matrice `visited` 
 *  de taille [height][width].
 *
 * - `info->visited = malloc(sizeof(bool*) * info->height)`.
 * - Pour chaque rangée r ∈ [0..height-1], 
 *   alloue `calloc(info->width, sizeof(bool))`.
 * - Si échec d’allocation, appelle 
 *  `error_and_exit(parser, ERR_MAP_MALLOC)`.
 *
 * @param info   Pointeur vers la structure `t_mapinfo` (
 * contient `height`, `width`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	init_visited_map(t_mapinfo *info, t_parser *parser)
{
	int	r;

	info->visited = malloc(sizeof(bool *) * info->height);
	if (!info->visited)
		error_and_exit(parser, ERR_MAP_MALLOC);
	r = 0;
	while (r < info->height)
	{
		info->visited[r] = calloc(info->width, sizeof(bool));
		if (!info->visited[r])
			error_and_exit(parser, ERR_MAP_MALLOC);
		r++;
	}
}

/**
 * @brief Libère la structure `mapinfo` (map2d et visited).
 *
 * - Pour chaque rangée r ∈ [0..height-1] : 
 *  `free(info->map2d[r])`, `free(info->visited[r])`.
 * - `free(info->map2d)`, `free(info->visited)`.
 *
 * @param info Pointeur vers la structure `t_mapinfo`.
 */
void	free_mapinfo(t_mapinfo *info)
{
	int	r;

	r = 0;
	while (r < info->height)
	{
		free(info->map2d[r]);
		free(info->visited[r]);
		r++;
	}
	free(info->map2d);
	free(info->visited);
}

/**
 * @brief Calcule la hauteur de la map (nombre de lignes) à partir de `map`.
 *
 * @param map Tableau de chaînes (char **).
 * @return int Nombre de lignes jusqu’au NULL.
 */
int	get_map_height(char **map)
{
	int	height;

	height = 0;
	while (map[height])
		height++;
	return (height);
}

/**
 * @brief Vérifie que la map n’est pas vide (height == 0).
 *
 * - Si `height == 0`, affiche `ERR_MAP_EMPTY` sur stderr 
 * et `exit(EXIT_FAILURE)`.
 *
 * @param height Hauteur de la map (nombre de lignes).
 */
void	check_map_empty(int height)
{
	if (height == 0)
	{
		ft_putstr_fd(ERR_MAP_EMPTY, 2);
		exit(EXIT_FAILURE);
	}
}

/**
 * @brief Calcule la largeur maximale (nombre de colonnes) 
 * parmi les lignes de `map`.
 *
 * - Parcourt i ∈ [0..height-1], `len = strlen(map[i])`. 
 * Si `len > width`, met à jour.
 *
 * @param map    Tableau de chaînes (char **).
 * @param height Nombre de lignes de `map`.
 * @return int   Largeur maximale trouvée.
 */
int	get_max_width(char **map, int height)
{
	int	i;
	int	len;
	int	width;

	width = 0;
	i = 0;
	while (i < height)
	{
		len = (int)ft_strlen(map[i]);
		if (len > width)
			width = len;
		i++;
	}
	return (width);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:35 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:57:23 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Affiche une erreur si la ligne `row` est vide et quitte (exit).
 *
 * - Affiche "Error\nLigne : <row> est vide.\n" 
 *   sur stderr via ft_putstr_fd/ft_putnbr_fd.
 * - Appelle `exit_text_with_error("", parser)`.
 *
 * @param row    Index de la ligne considérée.
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	print_line_error_empty(int row, t_parser *parser)
{
	ft_putstr_fd("Error\nLigne : ", 2);
	ft_putnbr_fd(row, 2);
	ft_putstr_fd(" est vide.\n", 2);
	exit_text_with_error("", parser);
}

/**
 * @brief Affiche une erreur si la ligne `row` 
 * ne se termine pas par '1' et quitte (exit).
 *
 * - Affiche "Error\nLigne : <row> ne finit pas par un mur '1'.\n".
 * - Appelle `exit_text_with_error("", parser)`.
 *
 * @param row    Index de la ligne considérée.
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	print_line_error_end(int row, t_parser *parser)
{
	ft_putstr_fd("Error\nLigne : ", 2);
	ft_putnbr_fd(row, 2);
	ft_putstr_fd(" ne finit pas par un mur '1'.\n", 2);
	exit_text_with_error("", parser);
}

/**
 * @brief Vérifie que `line` commence (après espaces) par le caractère '1'.
 *
 * - Avance un index i tant que `line[i]` est ' ' ou '\t'.
 * - Si `line[i] != '1'`, 
 *   appelle `exit_text_with_error(ERR_MAP_START_LINE, parser)`.
 *
 * @param line   Chaîne de la ligne de la map.
 * @param parser Pointeur vers `t_parser`.
 */
static void	check_line_starts_with_wall(char *line, t_parser *parser)
{
	int	i;

	i = 0;
	while (line[i] == ' ' || line[i] == '\t')
		i++;
	if (line[i] != '1')
		exit_text_with_error(ERR_MAP_START_LINE, parser);
}

/**
 * @brief Vérifie que `line` se termine (avant espaces) par le caractère '1'.
 *
 * - Parcourt depuis la fin (strlen(line)-1) 
 * en décrémentant tant que c'est ' ' ou '\t'.
 * - Si l’indice devient < 0, appelle `print_line_error_empty(row, parser)`.
 * - Si `line[end] != '1'`, appelle `print_line_error_end(row, parser)`.
 *
 * @param line   Chaîne de la ligne de la map.
 * @param row    Numéro de ligne (pour le message d’erreur).
 * @param parser Pointeur vers `t_parser`.
 */
static void	check_line_ends_with_wall(char *line, int row, t_parser *parser)
{
	int	end;

	end = (int)strlen(line) - 1;
	while (end >= 0 && (line[end] == ' ' || line[end] == '\t'))
		end--;
	if (end < 0)
		print_line_error_empty(row, parser);
	if (line[end] != '1')
		print_line_error_end(row, parser);
}

/**
 * @brief Vérifie l’intégrité d’une ligne « middle » 
 * (ni première ni dernière) de la map.
 *
 * - Appelle `check_line_starts_with_wall` puis `check_line_ends_with_wall`.
 * - Utilisé pour les lignes intérieures à la carte (sans border).
 *
 * @param line   Chaîne de la ligne de la map.
 * @param row    Numéro de ligne (pour les messages d’erreur).
 * @param parser Pointeur vers `t_parser`.
 */
void	check_middle_line(char *line, int row, t_parser *parser)
{
	check_line_starts_with_wall(line, parser);
	check_line_ends_with_wall(line, row, parser);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_valid_map.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:41 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:20:51 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Vérifie que chaque ligne de la carte est bordée par des murs.
 *
 * - Pour row ∈ [0..h-1], initialise 
 * `inf.first = 0`, `inf.last = h-1`, `inf.row = row`.
 * - Appelle `check_line_borders(map[row], inf, parser)` 
 * pour vérifier chaque bord.
 *
 * @param map Tableau de chaînes représentant la map 2D.
 * @param h   Hauteur de la map (nombre de lignes).
 * @param p   Pointeur vers la structure `t_parser`.
 */
static void	check_map_borders(char **map, int h, t_parser *p)
{
	int			row;
	t_line_info	inf;

	row = 0;
	inf.first = 0;
	inf.last = h - 1;
	while (row < h)
	{
		inf.row = row;
		check_line_borders(map[row], inf, p);
		row++;
	}
}

/**
 * @brief Traite un caractère `ch` de la map pour compter le joueur éventuel.
 *
 * - Si `ch` invalide (pas '0'/'1'/'N'/'S'/'E'/'W'/' '), 
 * appelle `error_and_exit`.
 * - Si `ch ∈ {'N','S','E','W'}` : 
 * incrémente `*d->count`, stocke `*d->row = r`, `*d->col = c`,
 *   remplace `info->map2d[r][c]` par '0'.
 *
 * @param ch Caractère courant dans la map.
 * @param r  Ligne courante (index).
 * @param c  Colonne courante (index).
 * @param d  Pointeur vers `t_player_data` 
 * (contient count, row, col, info, parser).
 */
static void	store_player(char ch, int r, int c, t_player_data *d)
{
	if (!is_valid_map_char(ch))
		error_and_exit(d->parser, ERR_MAP_INVALID_CHAR);
	if (ch == 'N' || ch == 'S' || ch == 'E' || ch == 'W')
	{
		(*d->count)++;
		*d->row = r;
		*d->col = c;
		d->info->map2d[r][c] = '0';
	}
}

/**
 * @brief Parcourt toute la map 2D pour trouver un caractère de joueur.
 *
 * - Pour r ∈ [0..info->height-1], c ∈ [0..info->width-1]:
 *   - Appelle `store_player(info->map2d[r][c], r, c, d)`.
 *
 * @param info Pointeur vers `t_mapinfo` (contient `map2d`, `height`, `width`).
 * @param d    Pointeur vers `t_player_data` 
 * (contient count/row/col/info/parser).
 */
static void	scan_map_for_player(t_mapinfo *info, t_player_data *d)
{
	int		r;
	int		c;
	char	ch;

	r = 0;
	while (r < info->height)
	{
		c = 0;
		while (c < info->width)
		{
			ch = info->map2d[r][c];
			store_player(ch, r, c, d);
			c++;
		}
		r++;
	}
}

/**
 * @brief Valide qu’il y a exactement un joueur dans la map.
 *
 * - Initialise `player_cnt = 0`.
 * - Prépare `d.count = &player_cnt`, 
 * 		`d.row = pr`, `d.col = pc`, `d.info = info`, `d.parser = p`.
 * - Appelle `scan_map_for_player(info, &d)`.
 * - Si `player_cnt != 1`, 
 * 		appelle `error_and_exit(p, ERR_MAP_TEXT_MORE_THAN_ONE)`.
 *
 * @param info Pointeur vers `t_mapinfo` (contient la carte pad).
 * @param pr   Pointeur vers un entier où stocker la ligne du joueur.
 * @param pc   Pointeur vers un entier où stocker la colonne du joueur.
 * @param p    Pointeur vers la structure `t_parser`.
 */
static void	validate_and_get_player(t_mapinfo *info, int *pr,
			int *pc, t_parser *p)
{
	t_player_data	d;
	int				player_cnt;

	player_cnt = 0;
	d.count = &player_cnt;
	d.row = pr;
	d.col = pc;
	d.info = info;
	d.parser = p;
	scan_map_for_player(info, &d);
	if (player_cnt != 1)
		error_and_exit(p, ERR_MAP_TEXT_MORE_THAN_ONE);
}

/**
 * @brief Exécute la validation complète de la map et libère `info`.
 *
 * - `height = get_map_height(game->map)`.
 * - `check_map_empty(height)`.
 * - `check_map_borders(game->map, height, p)`.
 * - `init_mapinfo_struct(&info, game, p)`.
 * - `validate_and_get_player(&info, &player_r, &player_c, p)`.
 * - `init_visited_map(&info, p)`.
 * - Si `!dfs_closed(&info, player_r, player_c)`, 
 * appelle `error_and_exit(p, ERR_MAP_NOT_CLOSE)`.
 * - `free_mapinfo(&info)`.
 *
 * @param g Pointeur vers la structure de jeu (`t_game`).
 * @param p Pointeur vers la structure `t_parser`.
 */
void	check_validate_map(t_game *g, t_parser *p)
{
	t_mapinfo	info;
	int			player_r;
	int			player_c;
	int			height;

	height = get_map_height(g->map);
	check_map_empty(height);
	check_map_borders(g->map, height, p);
	init_mapinfo_struct(&info, g, p);
	validate_and_get_player(&info, &player_r, &player_c, p);
	init_visited_map(&info, p);
	if (!dfs_closed(&info, player_r, player_c))
		error_and_exit(p, ERR_MAP_NOT_CLOSE);
	free_mapinfo(&info);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:59:13 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Affiche un message d’erreur, nettoie le jeu, puis quitte.
 *
 * - Affiche `msg` sur stderr (`ft_putstr_fd`).
 * - Appelle `cleanup_before_exit(game)` pour libérer ressources jeu.
 * - `exit(EXIT_FAILURE)`.
 *
 * @param game Pointeur vers la structure de jeu (`t_game`).
 * @param msg  Message d’erreur à afficher.
 */
void	error_exit_game(t_game *game, char *msg)
{
	ft_putstr_fd(msg, 2);
	cleanup_before_exit(game);
	exit(EXIT_FAILURE);
}

/**
 * @brief Affiche un message d’erreur lié au parsing, 
 * nettoie parser + jeu, puis quitte.
 *
 * - Affiche `msg` sur stderr (`ft_putstr_fd`).
 * - Appelle `cleanup_all(parser->game, parser)` 
 *   pour libérer map, textures, etc.
 * - Libère `parser->state`.
 * - `exit(EXIT_FAILURE)`.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 * @param msg    Message d’erreur à afficher.
 */
void	exit_text_with_error(char *msg, t_parser *parser)
{
	ft_putstr_fd(msg, 2);
	cleanup_all(parser->game, parser);
	free(parser->state);
	exit(EXIT_FAILURE);
}

/**
 * @brief Affiche un message d’erreur, 
 * nettoie le parsing en cours, puis quitte.
 *
 * - Affiche `msg` sur stderr (`ft_putstr_fd`).
 * - Appelle `cleanup_get_next_line()` pour vider le buffer.
 * - Appelle `cleanup_all(parser->game, parser)` 
 *   pour libérer map, textures, etc.
 * - Libère `parser->state`.
 * - `exit(EXIT_FAILURE)`.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 * @param msg    Message d’erreur à afficher.
 */
void	error_and_exit(t_parser *parser, char *msg)
{
	ft_putstr_fd(msg, 2);
	cleanup_get_next_line();
	cleanup_all(parser->game, parser);
	free(parser->state);
	exit(EXIT_FAILURE);
}

/**
 * @brief Même que `error_and_exit`, mais libère d’abord un tableau `tokens`.
 *
 * - Libère chaque `tokens[i]` puis `tokens`.
 * - Affiche `msg` sur stderr, 
 * 	 appelle `cleanup_get_next_line()`, `cleanup_all(...)`.
 * - Libère `parser->state`.
 * - `exit(EXIT_FAILURE)`.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 * @param tokens Tableau de chaînes à libérer avant l’erreur.
 * @param msg    Message d’erreur à afficher.
 */
void	error_and_exit_free(t_parser *parser, char **tokens, char *msg)
{
	free_split(tokens);
	ft_putstr_fd(msg, 2);
	cleanup_get_next_line();
	cleanup_all(parser->game, parser);
	free(parser->state);
	exit(EXIT_FAILURE);
}

/**
 * @brief Vérifie qu’une valeur de couleur est dans [0,255], sinon quitte.
 *
 * - Si `value < 0` ou `value > 255` : affiche “Error: 
 * Couleur invalide: <value>” et `exit_text_with_error`.
 *
 * @param value  Entier représentant une composante R/G/B.
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	check_color_value(int value, t_parser *parser)
{
	if (value < 0 || value > 255)
	{
		ft_putstr_fd("Error:\nCouleur invalide: ", 2);
		ft_putnbr_fd(value, 2);
		ft_putchar_fd('\n', 2);
		exit_text_with_error("", parser);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   final_check.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 20:19:21 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:04:37 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Vérifie que toutes 
 * les textures (NO, SO, EA, WE) sont définies.
 *
 * - Si `game->config.no_texture == NULL`, 
 * appelle `error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_NO)`.
 * - Idem pour SO, EA, WE avec leurs macros d’erreur respectives.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	check_textures(t_game *game, t_parser *parser)
{
	if (!game->config.no_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_NO);
	if (!game->config.so_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_SO);
	if (!game->config.ea_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_EA);
	if (!game->config.we_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_WE);
}

/**
 * @brief Vérifie que les couleurs du sol (F) 
 * et du plafond (C) sont définies.
 *
 * - Si `game->config.floor_color[0] == -1`, 
 * appelle `error_and_exit(parser, ERR_COLOR_NOT_DEFINED_F)`.
 * - Si `game->config.ceiling_color[0] == -1`, 
 * appelle `error_and_exit(parser, ERR_COLOR_NOT_DEFINED_C)`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	check_colors(t_game *game, t_parser *parser)
{
	if (game->config.floor_color[0] == -1)
		error_and_exit(parser, ERR_COLOR_NOT_DEFINED_F);
	if (game->config.ceiling_color[0] == -1)
		error_and_exit(parser, ERR_COLOR_NOT_DEFINED_C);
}

/**
 * @brief Vérifie qu’une map a bien été lue (`game->map != NULL`).
 *
 * - Si la map n’existe pas, 
 * appelle `error_and_exit(parser, ERR_MAP_NOT_DEFINED)`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	check_map_presence(t_game *game, t_parser *parser)
{
	if (!game->map)
		error_and_exit(parser, ERR_MAP_NOT_DEFINED);
}

/**
 * @brief Effectue les vérifications finales après parsing des éléments.
 *
 * - Appelle `check_textures`, `check_colors`, `check_map_presence`.
 * - Ne fait rien si `game == NULL`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	final_check_config(t_game *game, t_parser *parser)
{
	if (!game)
		return ;
	check_textures(game, parser);
	check_colors(game, parser);
	check_map_presence(game, parser);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:56 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:29:20 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Libère toutes les ressources allouées dans `parser` 
 * (mais pas `parser` lui-même).
 *
 * - Si `parser == NULL`, ne fait rien.
 * - Si `parser->line != NULL`, free(line), met `line = NULL`.
 * - Si `parser->clean_line != NULL`, free(clean_line), met `clean_line = NULL`.
 * - Si `parser->trimmed != NULL`, free(trimmed), met `trimmed = NULL`.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	cleanup_parser_resources(t_parser *parser)
{
	if (!parser)
		return ;
	if (parser->line)
	{
		free(parser->line);
		parser->line = NULL;
	}
	if (parser->clean_line)
	{
		free(parser->clean_line);
		parser->clean_line = NULL;
	}
	if (parser->trimmed != NULL)
	{
		free(parser->trimmed);
		parser->trimmed = NULL;
	}
}

/**
 * @brief Libère un tableau de chaînes `map` et chaque chaîne à l’intérieur.
 *
 * - Si `map == NULL`, ne fait rien.
 * - Sinon, pour chaque `map[i] != NULL`, free(map[i]).
 * - Puis free(map).
 *
 * @param map Tableau de chaînes (map) à libérer.
 */
void	free_map(char **map)
{
	int	i;

	i = 0;
	if (!map)
		return ;
	while (map[i])
	{
		free(map[i]);
		i++;
	}
	free(map);
}

/**
 * @brief Libère tous les chemins de texture stockés dans `t_config`.
 *
 * - Si `config == NULL`, ne fait rien.
 * - Si `config->no_texture != NULL`, free, 
 * idem pour `so_texture`, `we_texture`, `ea_texture`.
 * - Met tous les champs `*_texture = NULL`.
 *
 * @param config Pointeur vers la structure `t_config`.
 */
void	free_config(t_config *config)
{
	if (!config)
		return ;
	if (config->no_texture)
		free(config->no_texture);
	if (config->so_texture)
		free(config->so_texture);
	if (config->we_texture)
		free(config->we_texture);
	if (config->ea_texture)
	{
		free(config->ea_texture);
	}
	config->no_texture = NULL;
	config->so_texture = NULL;
	config->we_texture = NULL;
	config->ea_texture = NULL;
}

/**
 * @brief Libère toutes les ressources du parsing *et* de la map dans `game`.
 *
 * - Si `game` et `parser` et `parser->state` et `!parser->state->game_cleaned` :
 *   - Met `parser->state->game_cleaned = true`.
 *   - `free_config(&game->config)`.
 *   - Si `game->map != NULL`, `free_map(game->map)`, met `game->map = NULL`.
 * - Si `parser` et `parser->state` et `!parser->state->parser_cleaned` :
 *   - Met `parser->state->parser_cleaned = true`.
 *   - `parser->trimmed = NULL`.
 *   - Appelle `cleanup_parser_resources(parser)`.
 * - Si `parser` et `parser->state` :
 *   - `free(parser->state)`, `parser->state = NULL`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	cleanup_all(t_game *game, t_parser *parser)
{
	if (game && parser && parser->state && !parser->state->game_cleaned)
	{
		parser->state->game_cleaned = true;
		free_config(&game->config);
		if (game->map)
		{
			free_map(game->map);
			game->map = NULL;
		}
	}
	if (parser && parser->state && !parser->state->parser_cleaned)
	{
		parser->state->parser_cleaned = true;
		parser->trimmed = NULL;
		cleanup_parser_resources(parser);
	}
	if (parser && parser->state)
	{
		free(parser->state);
		parser->state = NULL;
	}
}

/**
 * @brief Libère les ressources du jeu juste avant la sortie.
 *
 * - `free_config(&game->config)`.
 * - `free_map(game->map)`.
 * - Si `game->mlx != NULL` et `game->win != NULL`, appelle `mlx_destroy_window`.
 *
 * @param game Pointeur vers la structure de jeu (`t_game`).
 */
void	cleanup_before_exit(t_game *game)
{
	free_config(&game->config);
	free_map(game->map);
	if (game->mlx)
	{
		if (game->win)
			mlx_destroy_window(game->mlx, game->win);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 15:36:12 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:54:31 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Appelle `get_next_line(-42)` pour vider le buffer interne.
 *
 * - Nécessaire après la fin de la lecture de la file dans le parsing.
 */
void	cleanup_get_next_line(void)
{
	get_next_line(-42);
}

/**
 * @brief Libère un tableau de chaînes et chaque chaîne à l’intérieur.
 *
 * - Pour chaque `tokens[i] != NULL`, appelle `free(tokens[i])`, puis
 *   `free(tokens)`.
 *
 * @param tokens Tableau de chaînes à libérer.
 */
void	free_split(char **tokens)
{
	int	i;

	i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:59 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:16:31 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Copie la chaîne `src` dans `dest` 
 * et complète par espaces jusqu’à `width`.
 *
 * - Calcule `len = strlen(src)`.
 * - Copie caractère par caractère `src` dans `dest`.
 * - Remplit `dest[len..width-1]` avec des espaces.
 * - Met `dest[width] = '\0'`.
 *
 * @param dest Chaîne déjà allouée de longueur ≥ width+1.
 * @param src  Chaîne source (une ligne de map).
 * @param width Largeur cible (colonnes) pour le padding.
 */
void	copy_and_pad_line(char *dest, char *src, int width)
{
	int	len;
	int	c;

	len = (int)ft_strlen(src);
	c = 0;
	while (c < len)
	{
		dest[c] = src[c];
		c++;
	}
	while (c < width)
	{
		dest[c] = ' ';
		c++;
	}
	dest[width] = '\0';
}

/**
 * @brief Initialise une structure `t_mapinfo` à partir de `game->map`.
 *
 * - `h = get_map_height(game->map)`, `w = get_max_width(game->map, h)`.
 * - `info->height = h`, `info->width = w`.
 * - Alloue `info->map2d = malloc(sizeof(char*) * h)`.
 * - Pour chaque ligne r ∈ [0..h-1] :
 *   - Alloue `info->map2d[r] = malloc(sizeof(char) * (w + 1))`.
 *   - Si échec, `error_and_exit(parser, ERR_MAP_MALLOC)`.
 *   - Appelle `copy_and_pad_line(info->map2d[r], game->map[r], w)`.
 *
 * @param info   Pointeur vers `t_mapinfo` à initialiser.
 * @param game   Pointeur vers la structure de jeu (`t_game`), contient `map`.
 * @param parser Pointeur vers la structure `t_parser` pour gérer les erreurs.
 */
void	init_mapinfo_struct(t_mapinfo *info, t_game *game, t_parser *parser)
{
	int	r;
	int	h;
	int	w;

	h = get_map_height(game->map);
	w = get_max_width(game->map, h);
	info->height = h;
	info->width = w;
	info->map2d = malloc(sizeof(char *) * h);
	if (!info->map2d)
		error_and_exit(parser, ERR_MAP_MALLOC);
	r = 0;
	while (r < h)
	{
		info->map2d[r] = malloc(sizeof(char) * (w + 1));
		if (!info->map2d[r])
			error_and_exit(parser, ERR_MAP_MALLOC);
		copy_and_pad_line(info->map2d[r], game->map[r], w);
		r++;
	}
}

/**
 * @brief Initialise la structure `t_parser` pour démarrer le parsing.
 *
 * - Met `match_text`, `match_color`, `map_started`, 
 * `map_is_done`, `empty_line_after_map` à false.
 * - Met `line`, `clean_line`, `trimmed` à NULL.
 * - Stocke `parser->game = game`.
 * - Alloue `parser->state = malloc(sizeof(t_cleanup_state))` et, si OK, 
 *   met `state->game_cleaned = false` et `state->parser_cleaned = false`.
 *
 * @param parser Pointeur vers `t_parser` à initialiser.
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 */
void	init_parser(t_parser *parser, t_game *game)
{
	parser->match_text = 0;
	parser->match_color = 0;
	parser->map_started = false;
	parser->map_is_done = false;
	parser->empty_line_after_map = false;
	parser->line = NULL;
	parser->clean_line = NULL;
	parser->trimmed = NULL;
	parser->game = game;
	parser->state = malloc(sizeof(t_cleanup_state));
	if (parser->state)
	{
		parser->state->game_cleaned = false;
		parser->state->parser_cleaned = false;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:30 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:13:59 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Traite une ligne lue : texture, couleur ou map.
 *
 * - Si `parser->clean_line == NULL` ou vide, 
 * appelle `handle_empty_line(parser)`.
 * - Sinon, si `clean_line` commence par "NO "/"SO "/"WE "/"EA ", 
 * appelle `process_texture_line`.
 * - Sinon, si commence par "F "/"C ", appelle `process_color_line`.
 * - Sinon, appelle `process_map_line`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	process_line(t_game *game, t_parser *parser)
{
	if (!parser->clean_line || ft_strlen(parser->clean_line) == 0)
	{
		handle_empty_line(parser);
		return ;
	}
	if (ft_strlen(parser->clean_line) > 0 && (!ft_strncmp(parser->clean_line,
				"NO ", 3) || !ft_strncmp(parser->clean_line, "SO ", 3)
			|| !ft_strncmp(parser->clean_line, "WE ", 3)
			|| !ft_strncmp(parser->clean_line, "EA ", 3)))
	{
		process_texture_line(game, parser);
	}
	else if (ft_strlen(parser->clean_line) > 0
		&& (!ft_strncmp(parser->clean_line, "F ", 2)
			|| !ft_strncmp(parser->clean_line, "C ", 2)))
	{
		process_color_line(game, parser);
	}
	else
		process_map_line(game, parser);
}

/**
 * @brief Boucle principale du parsing : lit ligne par ligne via `get_next_line`.
 *
 * - Lit la première ligne (`parser->line = get_next_line(fd)`).
 * - Tant que `parser->line != NULL` :
 *   - `parser->clean_line = ft_strtrim(parser->line, " \t\n")`.
 *   - Appelle `process_line(game, parser)`.
 *   - Libère `parser->clean_line` et `parser->line`.
 *   - Lit la ligne suivante.
 * - À la fin, appelle `cleanup_get_next_line()`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 * @param fd     Descripteur de fichier de la map.
 */
static void	parse_loop(t_game *game, t_parser *parser, int fd)
{
	parser->line = get_next_line(fd);
	if (!parser->line)
	{
		ft_putstr_fd(ERR_MAP_EMPTY, 2);
		close(fd);
		cleanup_get_next_line();
		exit(EXIT_FAILURE);
	}
	while (parser->line)
	{
		parser->clean_line = ft_strtrim(parser->line, " \t\n");
		process_line(game, parser);
		if (parser->clean_line)
		{
			free(parser->clean_line);
			parser->clean_line = NULL;
		}
		free(parser->line);
		parser->line = NULL;
		parser->line = get_next_line(fd);
	}
	cleanup_get_next_line();
}

/**
 * @brief Vérifie la validité finale après le parsing.
 *
 * - Si `game->map != NULL` :
 *   - Appelle `check_validate_map` (vérification de fermeture).
 *   - Appelle `final_check_config` (textures/couleurs/map).
 *   - Retourne 0.
 * - Sinon, affiche `ERR_MAP_NOT_DEFINED` et retourne 1.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 * @return int 0 si parsing OK, 1 sinon.
 */
static int	check_parsing(t_game *game, t_parser *parser)
{
	if (game->map)
	{
		check_validate_map(game, parser);
		final_check_config(game, parser);
		return (0);
	}
	else
	{
		ft_putstr_fd(ERR_MAP_NOT_DEFINED, 2);
		return (1);
	}
}

/**
 * @brief Ouvre le fichier `.cub` et vérifie l’extension “.cub”.
 *
 * - Appelle `open_map_file(file_name)`. Si retourné -1, 
 *   appelle `cleanup_get_next_line()` et `free(parser->state)` puis retourne -1.
 * - Sinon, retourne le fd valide.
 *
 * @param file_name Nom du fichier .cub.
 * @param parser    Pointeur vers la structure `t_parser`.
 * @return int Descripteur de fichier (>= 0) ou -1 en cas d’erreur.
 */
static int	open_and_validate(char *file_name, t_parser *parser)
{
	int	fd;

	fd = open_map_file(file_name);
	if (fd == -1)
	{
		cleanup_get_next_line();
		free(parser->state);
		return (-1);
	}
	return (fd);
}

/**
 * @brief Fonction principale de parsing du programme.
 *
 * - Initialise `parser` via `init_parser`.
 * - Définit `game->map = NULL`.
 * - `fd = open_and_validate(file_name, &parser)`. Si -1, retourne EXIT_FAILURE.
 * - Appelle `parse_loop(game, &parser, fd)`.
 * - `result = check_parsing(game, &parser)`. Ferme FD.
 * - Si `result != EXIT_SUCCESS` :
 *   - Appelle `cleanup_get_next_line()`, 
 * `cleanup_all(game, &parser)`, 
 * `free(parser.state)`, 
 *  retourne `result`.
 * - Sinon, `cleanup_get_next_line()`, `free(parser.state)`, retourne `result`.
 *
 * @param game      Pointeur vers la structure de jeu (`t_game`).
 * @param file_name Chaîne avec le nom du fichier .cub.
 * @return int EXIT_SUCCESS si OK, sinon code d’erreur.
 */
int	ft_parse(t_game *game, char *file_name)
{
	t_parser	parser;
	int			fd;
	int			result;

	init_parser(&parser, game);
	game->map = NULL;
	fd = open_and_validate(file_name, &parser);
	if (fd == -1)
		return (EXIT_FAILURE);
	parse_loop(game, &parser, fd);
	result = check_parsing(game, &parser);
	close(fd);
	if (result != EXIT_SUCCESS)
	{
		cleanup_get_next_line();
		cleanup_all(game, &parser);
		free(parser.state);
		return (result);
	}
	cleanup_get_next_line();
	free(parser.state);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_color.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:12 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:53:52 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Scinde la chaîne `str` par « , », 
 * vérifie qu’il y a exactement 3 tokens.
 *
 * - Appelle `ft_split(str, ',')`.
 * - Si `tokens == NULL`, appelle `error_and_exit(parser, ERR_MEM_ALLOC_COLOR)`.
 * - Compte le nombre de tokens : si ≠ 3, libère tokens et 
 *  `error_and_exit_free(parser, tokens, ERR_INVALID_COLOR_FORMAT)`.
 * - Vérifie : pour i ∈ [0..2], si `tokens[i] == NULL`, 
 *   libère et `error_and_exit_free(parser, 
 *   tokens, "Format de couleur invalide\n")`.
 * - Renvoie le tableau `tokens` (à libérer ensuite).
 *
 * @param str    Chaîne « r,g,b » à scinder.
 * @param parser Pointeur vers la structure `t_parser`.
 * @return char** Tableau de 3 chaînes (tokens), 
 * ou ne retourne pas en cas d’erreur.
 */
static char	**split_and_validate_color(char *str, t_parser *parser)
{
	char	**tokens;
	int		count;
	int		i;

	tokens = ft_split(str, ',');
	if (!tokens)
		error_and_exit(parser, ERR_MEM_ALLOC_COLOR);
	count = 0;
	while (tokens[count])
		count++;
	if (count != 3)
		error_and_exit_free(parser, tokens, ERR_INVALID_COLOR_FORMAT);
	i = 0;
	while (i < 3)
	{
		if (!tokens[i])
			error_and_exit_free(parser, tokens,
				"Error\nFormat de couleur invalide\n");
		i++;
	}
	return (tokens);
}

/**
 * @brief Assigne les valeurs numériques parsed dans `tokens[]` à `target[0..2]`.
 *
 * - Si `target[0] != -1` déjà défini, libère tokens et 
 *   `error_and_exit_free(parser, tokens, "Couleur déjà définie\n")`.
 * - Pour i de 0 à 2, `target[i] = ft_atoi(tokens[i])` 
 *   puis `check_color_value(target[i], parser)`.
 *
 * @param target Pointeur vers le tableau de 3 entiers 
 * (floor_color ou ceiling_color).
 * @param tokens Tableau de 3 chaînes numériques (r,g,b).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	assign_color(int *target, char **tokens, t_parser *parser)
{
	int	i;

	if (target[0] != -1)
		error_and_exit_free(parser, tokens, "Error\nCouleur déjà définie.\n");
	i = 0;
	while (i < 3)
	{
		target[i] = ft_atoi(tokens[i]);
		check_color_value(target[i], parser);
		i++;
	}
}

/**
 * @brief Parse une ligne de couleur (clean_line commence par "F " ou "C ").
 *
 * - Scinde `color_str` (chaine après « F » ou « C ») 
 * 	 via `split_and_validate_color`.
 * - Si `clean_line` commence par "F ", 
 * 	 appelle `assign_color(game->config.floor_color,…)`.
 *   Sinon si "C ", appelle `assign_color(game->config.ceiling_color,…)`.
 *   Sinon, libère tokens et 
 * 	`error_and_exit(parser, ERR_UNKNOWN_COLOR_IDENTIFIER)`.
 * - Libère tokens à la fin.
 *
 * @param game       Pointeur vers la structure de jeu (`t_game`).
 * @param clean_line Chaîne nettoyée (trimmed) de la ligne entière 
 * (ex. "F 220,100,0").
 * @param color_str  Portion après « F » ou « C » (ex. "220,100,0").
 * @param parser     Pointeur vers la structure `t_parser`.
 */
void	parse_color(t_game *game, char *clean_line, char *color_str,
		t_parser *parser)
{
	char	**tokens;

	tokens = split_and_validate_color(color_str, parser);
	if (!ft_strncmp(clean_line, "F ", 2))
		assign_color(game->config.floor_color, tokens, parser);
	else if (!ft_strncmp(clean_line, "C ", 2))
		assign_color(game->config.ceiling_color, tokens, parser);
	else
	{
		free_split(tokens);
		error_and_exit(parser, ERR_UNKNOWN_COLOR_IDENTIFIER);
	}
	free_split(tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:16 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:18:05 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Ouvre un fichier `.cub` après vérification d’extension.
 *
 * - `len = strlen(file_name)`. Si `len < 4` 
 * ou `file_name[len-4..] != ".cub"`,
 *   affiche `"Error\nFichier invalide : extension '.cub' requise\n"`, 
 * retourne -1.
 * - Appelle `open(file_name, O_RDONLY)`. Si `fd == -1`, 
 * affiche `ERR_OPEN_FILE` + `file_name`, retourne -1.
 * - Sinon, retourne le descripteur `fd`.
 *
 * @param file_name Nom du fichier .cub à ouvrir.
 * @return int Descripteur de fichier (>= 0) ou -1 en cas d’erreur.
 */
int	open_map_file(char *file_name)
{
	int		fd;
	size_t	len;

	len = ft_strlen(file_name);
	if (len < 4 || ft_strcmp(file_name + len - 4, ".cub") != 0)
	{
		ft_putstr_fd(
			"Error\nFichier invalide : extension '.cub' requise\n", 2);
		return (-1);
	}
	fd = open(file_name, O_RDONLY);
	if (fd == -1)
	{
		ft_putstr_fd(ERR_OPEN_FILE, 2);
		ft_putstr_fd(file_name, 2);
		ft_putstr_fd("\n", 2);
	}
	return (fd);
}

/**
 * @brief Vérifie que la chaîne `str` ne comporte que des chiffres.
 *
 * - Parcourt `str[i]` tant que `isdigit(str[i])` est vrai.
 * - Si rencontre un caractère non numérique, renvoie 0.
 * - Sinon renvoie 1.
 *
 * @param str Chaîne à tester.
 * @return int 1 si tous les caractères sont des chiffres, 0 sinon.
 */
int	is_integer(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

/**
 * @brief Vérifie l’accès (read-only) à un fichier de texture.
 *
 * - `fd = open(parser->trimmed, O_RDONLY)`. Si `fd == -1` ou 
 *   la fin de `trimmed` n’est pas “.xpm”, affiche  
 *   `"Error\nfichier de texture inaccessible: " + trimmed`, 
 *   appelle `cleanup_all` et `exit(EXIT_FAILURE)`.
 * - Sinon, `close(fd)`.
 *
 * @param parser Pointeur vers la structure `t_parser` 
 * (contient `trimmed` et `game`).
 */
void	check_access(t_parser *parser)
{
	int		fd;
	char	*trimmed;

	trimmed = parser->trimmed;
	fd = open(trimmed, O_RDONLY);
	if (fd == -1 || ft_strcmp(trimmed + ft_strlen(trimmed) - 4, ".xpm"))
	{
		ft_putstr_fd("Error\nfichier de texture inaccessible: ", 2);
		ft_putstr_fd(trimmed, 2);
		cleanup_all(parser->game, parser);
		close(fd);
		exit(EXIT_FAILURE);
	}
	close(fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/06/23 12:06:14 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Assigne une chaîne `trimmed` à `*texture_field` si non déjà définie.
 *
 * - Si `*texture_field != NULL`, affiche `error_msg`, libère `*texture_field`,
 *   appelle `cleanup_all` et `exit(EXIT_FAILURE)`.
 * - Sinon, `*texture_field = ft_strdup(trimmed)`. 
 * Si NULL, appelle `exit_text_with_error`.
 *
 * @param texture_field Pointeur vers le champ de texture (NO/SO/WE/EA).
 * @param trimmed       Chemin de texture déjà trimé.
 * @param error_msg     Message d’erreur si déjà défini ou si échec d’allocation.
 * @param parser        Pointeur vers la structure `t_parser`.
 */
void	assign_if_not_defined(char **texture_field, char *trimmed,
	char *error_msg, t_parser *parser)
{
	if (*texture_field != NULL)
	{
		ft_putstr_fd(error_msg, 2);
		free(*texture_field);
		*texture_field = NULL;
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	*texture_field = ft_strdup(trimmed);
	if (*texture_field == NULL)
		exit_text_with_error(error_msg, parser);
}

/**
 * @brief Traite une ligne de la map ou gère une ligne vide 
 * après que la map ait commencé.
 *
 * - Si `clean_line` est vide, appelle `handle_empty_line(parser)`.
 * - Sinon, appelle `check_map_errors(parser)`, met `parser->map_started = true`,
 *   puis `append_map_line(game, ft_strtrim(parser->line, "\n"))`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	process_map_line(t_game *game, t_parser *parser)
{
	if (ft_strlen(parser->clean_line) == 0)
	{
		handle_empty_line(parser);
		return ;
	}
	check_map_errors(parser);
	parser->map_started = true;
	append_map_line(game, ft_strtrim(parser->line, "\n"));
}

/**
 * @brief Marque qu’une ligne vide a été rencontrée après que la map a commencé.
 *
 * - Si `parser->map_started == true`, alors `parser->map_is_done = true` et
 *   `parser->empty_line_after_map = true`.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	handle_empty_line(t_parser *parser)
{
	if (parser->map_started)
	{
		parser->map_is_done = true;
		parser->empty_line_after_map = true;
	}
}

/**
 * @brief Vérifie les erreurs de map en fonction de l’état de parsing.
 *
 * - Si `parser->map_is_done == true`, affiche `ERR_MAP_ADD` et quitte.
 * - Si `parser->empty_line_after_map == true`, affiche `ERR_MAP_BAD` et quitte.
 * - Si ni `match_text` ni `match_color` n’ont été rencontrés, 
 * affiche `ERR_MAP_POS` et quitte.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	check_map_errors(t_parser *parser)
{
	if (parser->map_is_done)
	{
		ft_putstr_fd(ERR_MAP_ADD, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	if (parser->empty_line_after_map)
	{
		ft_putstr_fd(ERR_MAP_BAD, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	if (!parser->match_text || !parser->match_color)
	{
		ft_putstr_fd(ERR_MAP_POS, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_text.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:26 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:32:57 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Assigne la texture NO (Nord) si elle n’est pas déjà définie.
 *
 * - Vérifie via `assign_if_not_defined` que `game->config.no_texture` est vide.
 * - Si la chaîne `parser->trimmed` est valide, 
 * la duplique et la stocke dans `game->config.no_texture`.
 * - Sinon, `assign_if_not_defined` gère l’erreur (message + cleanup + exit).
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser` 
 * (contient `trimmed` et les infos d’erreur).
 */
static void	assign_no(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.no_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_NO, parser);
}

/**
 * @brief Assigne la texture SO (Sud) si elle n’est pas déjà définie.
 *
 * - Vérifie via `assign_if_not_defined` que `game->config.so_texture` est vide.
 * - Duplique `parser->trimmed` et stocke dans `game->config.so_texture`.
 * - Sinon, gère l’erreur.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	assign_so(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.so_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_SO, parser);
}

/**
 * @brief Assigne la texture WE (Ouest) si elle n’est pas déjà définie.
 *
 * - Vérifie via `assign_if_not_defined` que `game->config.we_texture` est vide.
 * - Duplique `parser->trimmed` et stocke dans `game->config.we_texture`.
 * - Sinon, gère l’erreur.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	assign_we(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.we_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_WE, parser);
}

/**
 * @brief Assigne la texture EA (Est) si elle n’est pas déjà définie.
 *
 * - Vérifie via `assign_if_not_defined` que `game->config.ea_texture` est vide.
 * - Duplique `parser->trimmed` et stocke dans `game->config.ea_texture`.
 * - Sinon, gère l’erreur.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	assign_ea(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.ea_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_EA, parser);
}

/**
 * @brief Assigne la texture NO/​SO/​WE/​EA selon la ligne lue.
 *
 * - Si `clean_line` commence par "NO ", appelle `assign_no(game, parser)`.
 * - Sinon si "SO ", appelle `assign_so`.
 * - Sinon si "WE ", appelle `assign_we`.
 * - Sinon si "EA ", appelle `assign_ea`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	assign_texture(t_game *game, t_parser *parser)
{
	if (!ft_strncmp(parser->clean_line, "NO ", 3))
		assign_no(game, parser);
	else if (!ft_strncmp(parser->clean_line, "SO ", 3))
		assign_so(game, parser);
	else if (!ft_strncmp(parser->clean_line, "WE ", 3))
		assign_we(game, parser);
	else if (!ft_strncmp(parser->clean_line, "EA ", 3))
		assign_ea(game, parser);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_color.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:34 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:03:02 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Traite une ligne de configuration de couleur (F ou C).
 *
 * - Met `parser->match_color = 1`.
 * - Si `clean_line[0] == 'F'`, `
 * parser->trimmed = ft_strtrim(clean_line + 2, " \t\n")`.
 *   Sinon si `'C'`, fait de même avec `clean_line + 2`.
 * - Si `parser->trimmed == NULL`, affiche `ERR_MEM_ALLOC_COLOR`, 
 * publie `exit(EXIT_FAILURE)`.
 * - Appelle `parse_color(game, parser->clean_line, parser->trimmed, parser)`.
 * - Libère `parser->trimmed`.
 *
 * @param game   Pointeur vers `t_game`.
 * @param parser Pointeur vers `t_parser`.
 */
void	process_color_line(t_game *game, t_parser *parser)
{
	parser->match_color = 1;
	if (parser->clean_line[0] == 'F')
		parser->trimmed = ft_strtrim(parser->clean_line + 2, " \t\n");
	else if (parser->clean_line[0] == 'C')
		parser->trimmed = ft_strtrim(parser->clean_line + 2, " \t\n");
	if (!parser->trimmed)
	{
		ft_putstr_fd(ERR_MEM_ALLOC_COLOR, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	parse_color(game, parser->clean_line, parser->trimmed, parser);
	free(parser->trimmed);
	parser->trimmed = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_text.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:37 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 19:15:22 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Extrait le chemin de texture selon le préfixe NO/SO/WE/EA.
 *
 * - Si `clean_line` commence par "NO", 
 * `parser->trimmed = ft_strtrim(clean_line+3, " \t\n")`.
 * - Sinon si "SO", idem avec +3, etc.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	trim_texture_path(t_parser *parser)
{
	if (parser->clean_line[0] == 'N' && parser->clean_line[1] == 'O')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'S' && parser->clean_line[1] == 'O')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'W' && parser->clean_line[1] == 'E')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'E' && parser->clean_line[1] == 'A')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
}

/**
 * @brief Vérifie que `parser->trimmed` n’est pas NULL après remise à zéro.
 *
 * - Si NULL, affiche `ERR_MEM_ALLOC_TEXTURE`, 
 * appelle `cleanup_all`, `exit(EXIT_FAILURE)`.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	check_trimmed_not_null(t_parser *parser)
{
	if (parser->trimmed == NULL)
	{
		ft_putstr_fd(ERR_MEM_ALLOC_TEXTURE, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

/**
 * @brief Vérifie que `parser->trimmed` n’est pas vide après trimming.
 *
 * - Si `strlen(parser->trimmed) == 0`, 
 * affiche `ERR_EMPTY_TEXTURE_PATH`, nettoie tout et quitte.
 *
 * @param parser Pointeur vers la structure `t_parser`.
 */
static void	check_trimmed_not_empty(t_parser *parser)
{
	if (ft_strlen(parser->trimmed) == 0)
	{
		ft_putstr_fd(ERR_EMPTY_TEXTURE_PATH, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

/**
 * @brief Traite une ligne de configuration de texture (NO/SO/WE/EA).
 *
 * - Met `parser->match_text = 1`.
 * - Appelle `trim_texture_path`, 
 * `check_trimmed_not_null`, `check_trimmed_not_empty`.
 * - Appelle `check_access(parser)`.
 * - Appelle `assign_texture(game, parser)`.
 * - Libère `parser->trimmed`.
 *
 * @param game   Pointeur vers la structure de jeu (`t_game`).
 * @param parser Pointeur vers la structure `t_parser`.
 */
void	process_texture_line(t_game *game, t_parser *parser)
{
	parser->match_text = 1;
	trim_texture_path(parser);
	check_trimmed_not_null(parser);
	check_trimmed_not_empty(parser);
	check_access(parser);
	assign_texture(game, parser);
	free(parser->trimmed);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   coord.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:24:03 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:32:10 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Vérifie si le caractère `c` désigne une orientation 
 * valide pour le joueur.
 *
 * - Renvoie true si `c` est 'N', 'S', 'E' ou 'W'.
 *
 * @param c Caractère à tester.
 * @return bool true si c ∈ {'N','S','E','W'}, false sinon.
 */
static bool	check_char(char c)
{
	return (c == 'N' || c == 'S' || c == 'E' || c == 'W');
}

/**
 * @brief Définit l’angle initial du joueur en fonction du caractère direction.
 *
 * - Si 'N', angle = -PI/2 ; 'S' → 3PI/2 ; 'E' → 0 ; 'W' → PI.
 *
 * @param c Caractère indiquant la direction ('N','S','E','W').
 * @param player Pointeur vers la structure `t_player` dont on met l’angle.
 */
static void	identify_char(char c, t_player *player)
{
	if (c == 'N')
		player->angle = -PI / 2;
	else if (c == 'S')
		player->angle = (PI * 3) / 2;
	else if (c == 'E')
		player->angle = 0.0;
	else if (c == 'W')
		player->angle = PI;
}

/**
 * @brief Trouve les coordonnées initiales du joueur dans la map.
 *
 * - Parcourt `game->map[row][col]` jusqu’à trouver un caractère d’orientation.
 * - Place `game->player.x = col * BLOCK + BLOCK/2`, 
 * `game->player.y = row * BLOCK + BLOCK/2`.
 * - Appelle `identify_char` pour définir `player->angle`.
 * - Retourne la structure `t_player` ainsi initialisée.
 *
 * @param game Pointeur vers la structure de jeu (contient `map` et `player`).
 * @return t_player Structure `player` mise à jour.
 */
t_player	get_coord(t_game *game)
{
	int	row;
	int	col;

	row = 0;
	col = 0;
	if (game->map)
	{
		while (game->map[row] != NULL)
		{
			col = 0;
			while (game->map[row][col] != '\0')
			{
				if (check_char(game->map[row][col]))
				{
					game->player.x = col * BLOCK + BLOCK / 2.0f;
					game->player.y = row * BLOCK + BLOCK / 2.0f;
					identify_char(game->map[row][col], &game->player);
					return (game->player);
				}
				col++;
			}
			row++;
		}
	}
	return (game->player);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   key.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 12:26:11 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:30:51 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Met à jour l’état d’une touche de déplacement/rétrécissement.
 *
 * - Si keycode == W/S/A/D/LEFT/RIGHT, modifie respectivement
 *   `p->key_up`, `p->key_down`, `p->key_left`, `p->key_right`,
 *   `p->left_rotate`, `p->right_rotate` à `state`.
 *
 * @param keycode Code de la touche reçue par MLX.
 * @param p Pointeur vers la structure `t_player`.
 * @param state true si la touche est pressée, false si relâchée.
 */
static void	set_player_key(int keycode, t_player *p, bool state)
{
	if (keycode == W)
		p->key_up = state;
	else if (keycode == S)
		p->key_down = state;
	else if (keycode == A)
		p->key_left = state;
	else if (keycode == D)
		p->key_right = state;
	else if (keycode == LEFT)
		p->left_rotate = state;
	else if (keycode == RIGHT)
		p->right_rotate = state;
}

/**
 * @brief Callback MLX lors de l’appui d’une touche.
 *
 * - Si ESC ou Q, appelle `cleanup_before_exit` et `exit(EXIT_SUCCESS)`.
 * - Sinon, appelle `set_player_key` pour mettre `p->key_* = true`.
 *
 * @param keycode Code de la touche pressée.
 * @param game Pointeur vers la structure de jeu (contient `t_player`).
 * @return int 0 (valeur ignorée par MLX).
 */
int	key_press(int keycode, t_game *game)
{
	if ((keycode == KEY_ESC || keycode == KEY_Q))
	{
		cleanup_before_exit(game);
		exit(EXIT_SUCCESS);
	}
	set_player_key(keycode, &game->player, true);
	return (0);
}

/**
 * @brief Callback MLX lors du relâchement d’une touche.
 *
 * - Appelle `set_player_key` pour mettre `p->key_* = false`.
 *
 * @param keycode Code de la touche relâchée.
 * @param game Pointeur vers la structure de jeu (contient `t_player`).
 * @return int 0 (valeur ignorée par MLX).
 */
int	key_release(int keycode, t_game *game)
{
	set_player_key(keycode, &game->player, false);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   player.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/31 12:37:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:37:19 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Initialise la position et l’orientation du joueur.
 *
 * - Place le joueur au centre : (`WIDTH/2`, `HEIGHT/2`).
 * - Angle initial = -PI/2 ; toutes les touches/mouvements à false.
 *
 * @param player Pointeur vers la structure `t_player`.
 */
void	init_player(t_player *player)
{
	player->x = WIDTH / 2;
	player->y = HEIGHT / 2;
	player->angle = -PI / 2;
	player->key_up = false;
	player->key_down = false;
	player->key_left = false;
	player->key_right = false;
	player->left_rotate = false;
	player->right_rotate = false;
}

/**
 * @brief Gère la rotation du joueur si les flags `left_rotate` 
 * ou `right_rotate` sont actifs.
 *
 * - Si `left_rotate`, décrémente `angle` de `ROT_SPEED`.
 * - Si `right_rotate`, incrémente `angle` de `ROT_SPEED`.
 * - Normalise l’angle dans [0, 2π).
 *
 * @param player Pointeur vers la structure `t_player`.
 */
static void	rotate_player(t_player *player)
{
	if (player->left_rotate)
		player->angle -= ROT_SPEED;
	if (player->right_rotate)
		player->angle += ROT_SPEED;
	if (player->angle < 0)
		player->angle += 2 * PI;
	else if (player->angle >= 2 * PI)
		player->angle -= 2 * PI;
}

/**
 * @brief Avance/le joueur en avant ou arrière selon `key_up`/`key_down`.
 *
 * - Calcule `dir = +1` si `key_up`, `-1` si `key_down`.
 * - Calcule `new_x = x + cos(angle) * MOVE_SPEED * dir`, idem pour `new_y`.
 * - Vérifie les collisions via `is_wall`. Met à jour `player->x`/`player->y` 
 * si le déplacement est valide.
 *
 * @param player Pointeur vers la structure `t_player`.
 * @param game   Pointeur vers la structure de jeu (pour tester `is_wall`).
 */
static void	translate_player(t_player *player, t_game *game)
{
	float	new_x;
	float	new_y;
	float	dir;

	if (player->key_up || player->key_down)
	{
		if (player->key_up)
			dir = 1.0f;
		else
			dir = -1.0f;
		new_x = player->x + cosf(player->angle) * MOVE_SPEED * dir;
		new_y = player->y + sinf(player->angle) * MOVE_SPEED * dir;
		if (!is_wall(new_x, player->y, game))
			player->x = new_x;
		if (!is_wall(player->x, new_y, game))
			player->y = new_y;
	}
}

/**
 * @brief Met à jour la position et l’orientation du joueur à chaque frame.
 *
 * - Appelle `rotate_player`, `translate_player`, `strafe_player` dans cet ordre.
 *
 * @param player Pointeur vers la structure `t_player`.
 * @param game   Pointeur vers la structure de jeu (pour collisions et état).
 */
static void	strafe_player(t_player *player, t_game *game)
{
	float	new_x;
	float	new_y;
	float	dir;

	if (player->key_left || player->key_right)
	{
		if (player->key_right)
			dir = 1.0f;
		else
			dir = -1.0f;
		new_x = player->x + cosf(player->angle + dir * PI / 2) * MOVE_SPEED;
		new_y = player->y + sinf(player->angle + dir * PI / 2) * MOVE_SPEED;
		if (!is_wall(new_x, player->y, game))
			player->x = new_x;
		if (!is_wall(player->x, new_y, game))
			player->y = new_y;
	}
}

void	move_player(t_player *player, t_game *game)
{
	rotate_player(player);
	translate_player(player, game);
	strafe_player(player, game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast_dda.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 18:36:20 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Initialise les coordonnées de la case courante 
 * et le vecteur direction du rayon.
 *
 * - map_x, map_y = case de départ (p->x/BLOCK, p->y/BLOCK).
 * - rdx = cos(ray_ang), rdy = sin(ray_ang).
 * - ddx = |1/rdx|, ddy = |1/rdy|.
 *
 * @param p Pointeur vers `t_player` (position du joueur).
 * @param ray_ang Angle du rayon en radians.
 * @param r Pointeur vers la structure `t_ray` à initialiser.
 */
static void	setup_ray(t_player *p, float ray_ang, t_ray *r)
{
	r->map_x = (int)(p->x / BLOCK);
	r->map_y = (int)(p->y / BLOCK);
	r->rdx = cosf(ray_ang);
	r->rdy = sinf(ray_ang);
	r->ddx = fabsf(1.0f / r->rdx);
	r->ddy = fabsf(1.0f / r->rdy);
}

/**
 * @brief Détermine la direction de pas (sx,sy) 
 * et les distances initiales sdx/sdy.
 *
 * - Si rdx < 0, sx = -1, sdx = (p->x/BLOCK - map_x) * ddx ; 
 * sinon sx = +1, sdx = ((map_x+1) - p->x/BLOCK) * ddx.
 * - Mêmes calculs pour rdy, sy, sdy.
 *
 * @param p Pointeur vers `t_player`.
 * @param r Pointeur vers `t_ray` 
 * contenant déjà `rdx`, `rdy`, `ddx`, `ddy`.
 */
static void	init_step(t_player *p, t_ray *r)
{
	if (r->rdx < 0)
	{
		r->sx = -1;
		r->sdx = (p->x / BLOCK - r->map_x) * r->ddx;
	}
	else
	{
		r->sx = 1;
		r->sdx = (r->map_x + 1.0f - p->x / BLOCK) * r->ddx;
	}
	if (r->rdy < 0)
	{
		r->sy = -1;
		r->sdy = (p->y / BLOCK - r->map_y) * r->ddy;
	}
	else
	{
		r->sy = 1;
		r->sdy = (r->map_y + 1.0f - p->y / BLOCK) * r->ddy;
	}
}

/**
 * @brief Exécute la boucle DDA jusqu’à toucher 
 * un mur (valeur '1' dans la map).
 *
 * - Compare sdx vs sdy pour savoir s’il faut avancer en x ou en y.
 * - Avance `map_x` ou `map_y` puis met à jour `sdx`/`sdy`.
 * - Fixe `side = 0` si on déplace en x, `side = 1` si en y.
 * - Si `map[map_y][map_x] == '1'` → stop.
 *
 * @param g Pointeur vers la structure de jeu (contient `map`).
 * @param r Pointeur vers la structure `t_ray`.
 */
static void	perform_dda(t_game *g, t_ray *r)
{
	while (true)
	{
		if (r->sdx < r->sdy)
		{
			r->sdx += r->ddx;
			r->map_x += r->sx;
			r->side = 0;
		}
		else
		{
			r->sdy += r->ddy;
			r->map_y += r->sy;
			r->side = 1;
		}
		if (g->map[r->map_y] && r->map_x >= 0
			&& r->map_x < (int)ft_strlen(g->map[r->map_y])
			&& g->map[r->map_y][r->map_x] == '1')
			break ;
	}
}

/**
 * @brief Calcule la distance perpendiculaire du joueur au mur.
 *
 * - Si `side == 0`: out[0] = (map_x - p->x/BLOCK + (1 - sx)/2) / rdx.
 * - Sinon: out[0] = (map_y - p->y/BLOCK + (1 - sy)/2) / rdy.
 * - out[1] ← `side`.
 *
 * @param p   Pointeur vers `t_player`.
 * @param r   Pointeur vers `t_ray` (côté, map_x, map_y, etc.).
 * @param out Tableau float de taille ≥ 2 :
 *            out[0] = distance perpendiculaire,
 *            out[1] = (float)side.
 */
static void	compute_perp(t_player *p, t_ray *r, float out[2])
{
	if (r->side == 0)
		out[0] = (r->map_x - p->x / BLOCK + (1 - r->sx) / 2.0f) / r->rdx;
	else
		out[0] = (r->map_y - p->y / BLOCK + (1 - r->sy) / 2.0f) / r->rdy;
	out[1] = (float)r->side;
}

/**
 * @brief Lance le raycasting DDA et renvoie la distance au mur 
 * et le côté touché.
 *
 * - Appelle `setup_ray`, `init_step`, `perform_dda`, `compute_perp`.
 * - Remplit `out[0]` (distance) et `out[1]` (side).
 *
 * @param p      Pointeur vers `t_player` (position + angle).
 * @param ray_ang Angle du rayon en radians.
 * @param g      Pointeur vers `t_game` (contient `map`).
 * @param out    Tableau float de sortie (distance + side).
 */
void	cast_ray(t_player *p, float ray_ang, t_game *g, float out[2])
{
	t_ray	r;

	setup_ray(p, ray_ang, &r);
	init_step(p, &r);
	perform_dda(g, &r);
	compute_perp(p, &r, out);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast_draw.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 18:38:40 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Trace une ligne verticale texturée à l’écran pour une slice de mur.
 *
 * - Calcule `step = (float)tex->height / (v.end - v.start + 1)`.
 * - Si `v.start < 0`, décale `tex_pos` et met `v.start = 0`.
 * - Vérifie `v.tex_x` (bornes entre 0 et `tex->width - 1`).
 * - Pour `y` de `v.start` à `v.end` (et < HEIGHT), 
 * 	 calcule `tex_y = (int)tex_pos & (tex->height - 1)`,
 *   incrémente `tex_pos` de `step`, 
 * 	 puis appelle `put_pixel(v.x, y, couleur, g)`.
 *
 * @param v   Structure `t_vline` définissant `x`, `start`, `end`, `tex_x`.
 * @param g   Pointeur vers `t_game` (pour accès à `data_img`).
 * @param tex Pointeur vers la texture (`t_tex`) utilisée pour cette slice.
 */
static void	draw_vertical_line(t_vline v, t_game *g, t_tex *tex)
{
	float	step;
	float	tex_pos;
	int		y;
	int		tex_y;

	step = (float)tex->height / (v.end - v.start + 1);
	tex_pos = 0.0f;
	if (v.start < 0)
	{
		tex_pos = -v.start * step;
		v.start = 0;
	}
	if (v.tex_x < 0)
		v.tex_x = 0;
	else if (v.tex_x >= tex->width)
		v.tex_x = tex->width - 1;
	y = v.start;
	while (y <= v.end && y < HEIGHT)
	{
		tex_y = (int)tex_pos & (tex->height - 1);
		tex_pos += step;
		put_pixel(v.x, y++, tex->pixels[tex_y * tex->width + v.tex_x], g);
	}
}

/**
 * @brief Sélectionne la bonne texture selon le côté touché par le rayon.
 *
 * - Si `side == 0` (mur vertical) : si `cos(ray_ang) > 0` → EAST, sinon WEST.
 * - Si `side == 1` (mur horizontal) : 
 * si `sin(ray_ang) > 0` → SOUTH, sinon NORTH.
 *
 * @param g       Pointeur vers la structure de jeu (contient `textures[]`).
 * @param side    0 = mur vertical, 1 = mur horizontal.
 * @param ray_ang Angle du rayon en radians.
 * @return t_tex* Pointeur vers la texture correspondante.
 */
static t_tex	*select_texture(t_game *g, int side, float ray_ang)
{
	if (side == 0)
	{
		if (cosf(ray_ang) > 0)
			return (&g->textures[EAST]);
		else
			return (&g->textures[WEST]);
	}
	else
	{
		if (sinf(ray_ang) > 0)
			return (&g->textures[SOUTH]);
		else
			return (&g->textures[NORTH]);
	}
}

/**
 * @brief Calcule la coordonnée `hit` sur le mur (entre 0 et BLOCK).
 *
 * - Si `side == 0` : renvoie `p->y + sin(ray_ang) * perp_dist * BLOCK`.
 * - Sinon : renvoie `p->x + cos(ray_ang) * perp_dist * BLOCK`.
 *
 * @param p        Pointeur vers `t_player` (position du joueur).
 * @param perp_dist Distance perpendiculaire renvoyée par DDA.
 * @param ray_ang  Angle du rayon en radians.
 * @param side     0 ou 1 (côté touché).
 * @return float Valeur de la coordonnée d’impact sur le mur (en unités de jeu).
 */
static float	compute_hit(t_player *p, float perp_dist, float ray_ang,
		int side)
{
	if (side == 0)
		return (p->y + sinf(ray_ang) * perp_dist * BLOCK);
	else
		return (p->x + cosf(ray_ang) * perp_dist * BLOCK);
}

/**
 * @brief Dessine une slice verticale en appelant `draw_vertical_line`.
 *
 * - Calcule `proj_plane = (WIDTH/2) / tan(FOV_ANGLE_RAD/2)`.
 * - `v.start = (HEIGHT - (int)(proj_plane / perp_dist)) / 2`.
 * - `v.end = v.start + (int)(proj_plane / perp_dist)`.
 * - `v.x = x`.
 * - `tex = select_texture(...)`.
 * - `v.tex_x = (int)(fmod(compute_perp_hit(...)/BLOCK) * tex->width)`.
 * - Appelle `draw_vertical_line(v, g, tex)`.
 *
 * @param x       Abscisse de la slice à l’écran (colonne pixel).
 * @param g       Pointeur vers la structure de jeu.
 * @param out     Tableau float où out[0] = distance, out[1] = side.
 * @param ray_ang Angle du rayon en radians.
 */
static void	draw_slice(int x, t_game *g, float out[2], float ray_ang)
{
	float	perp_dist;
	float	proj_plane;
	t_tex	*tex;
	t_vline	v;

	perp_dist = out[0];
	proj_plane = (WIDTH / 2.0f) / tanf(FOV_ANGLE_RAD * 0.5f);
	v.start = (HEIGHT - (int)(proj_plane / perp_dist)) / 2;
	v.end = v.start + (int)(proj_plane / perp_dist);
	v.x = x;
	tex = select_texture(g, (int)out[1], ray_ang);
	v.tex_x = (int)(fmodf(compute_hit(&g->player, perp_dist, ray_ang,
					(int)out[1]), BLOCK) / BLOCK * tex->width);
	draw_vertical_line(v, g, tex);
}

/**
 * @brief Lance le dessin d’une tranche au pixel horizontal `x`.
 *
 * - Appelle `cast_ray`, récupère `out[2]` (distance + side).
 * - Si DEBUG == 0, appelle `draw_slice(x, g, out, ray_ang)`.
 *
 * @param p      Pointeur vers `t_player` (position + angle).
 * @param g      Pointeur vers `t_game`.
 * @param ray_ang Angle du rayon en radians.
 * @param x      Abscisse de la colonne à dessiner.
 */
void	draw_line(t_player *p, t_game *g, float ray_ang, int x)
{
	float	out[2];

	cast_ray(p, ray_ang, g, out);
	if (!DEBUG)
		draw_slice(x, g, out, ray_ang);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast_render.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 18:40:50 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Dessine la moitié supérieure (plafond) 
 * de l’écran avec une couleur donnée.
 *
 * - Parcourt y de 0 à `HEIGHT/2 - 1`, x de 0 à `WIDTH - 1`.
 * - Appelle `put_pixel(x, y, col, g)` pour chaque pixel.
 *
 * @param g   Pointeur vers la structure de jeu (`t_game`).
 * @param col Couleur 24 bits (0xRRGGBB) pour le plafond.
 */
static void	draw_ceiling(t_game *g, int col)
{
	int	y;
	int	x;

	y = 0;
	while (y < HEIGHT / 2)
	{
		x = 0;
		while (x < WIDTH)
		{
			put_pixel(x, y, col, g);
			x++;
		}
		y++;
	}
}

/**
 * @brief Dessine la moitié inférieure (sol) de l’écran avec une couleur donnée.
 *
 * - Parcourt y de `HEIGHT/2` à `HEIGHT - 1`, x de 0 à `WIDTH - 1`.
 * - Appelle `put_pixel(x, y, col, g)` pour chaque pixel.
 *
 * @param g   Pointeur vers la structure de jeu (`t_game`).
 * @param col Couleur 24 bits (0xRRGGBB) pour le sol.
 */
static void	draw_floor(t_game *g, int col)
{
	int	y;
	int	x;

	y = HEIGHT / 2;
	while (y < HEIGHT)
	{
		x = 0;
		while (x < WIDTH)
		{
			put_pixel(x, y, col, g);
			x++;
		}
		y++;
	}
}

/**
 * @brief Remplit le plafond et le sol de l’écran 
 * avec leurs couleurs.
 *
 * - Récupère `ceil_col` depuis `g->config.ceiling_color`.
 * - Récupère `floor_col` depuis `g->config.floor_color`.
 * - Appelle `draw_ceiling` puis `draw_floor`.
 *
 * @param g Pointeur vers la structure de jeu (`t_game`).
 */
static void	draw_floor_and_ceiling(t_game *g)
{
	int	ceil_col;
	int	floor_col;

	ceil_col = (g->config.ceiling_color[0] << 16)
		| (g->config.ceiling_color[1] << 8)
		| g->config.ceiling_color[2];
	floor_col = (g->config.floor_color[0] << 16)
		| (g->config.floor_color[1] << 8)
		| g->config.floor_color[2];
	draw_ceiling(g, ceil_col);
	draw_floor(g, floor_col);
}

/**
 * @brief Parcourt toutes les colonnes X de l’écran et appelle `draw_line`.
 *
 * - Calcule `fov = FOV_ANGLE_RAD`, `half = fov/2`.
 * - Pour chaque `i` de 0 à `WIDTH - 1`, 
 *   `ang = player.angle - half + (i * fov / WIDTH)`.
 * - Ajuste `ang` dans [0, 2π) si hors bornes.
 * - Appelle `draw_line(p, g, ang, i)`.
 *
 * @param g Pointeur vers la structure de jeu (`t_game`).
 */
static void	render_rays(t_game *g)
{
	t_player	*p;
	float		fov;
	float		half;
	int			i;
	float		ang;

	p = &g->player;
	fov = FOV_ANGLE_RAD;
	half = fov * 0.5f;
	i = 0;
	while (i < WIDTH)
	{
		ang = p->angle - half + (i * fov / (float)WIDTH);
		if (ang < 0)
			ang += 2 * PI;
		else if (ang >= 2 * PI)
			ang -= 2 * PI;
		draw_line(p, g, ang, i);
		i++;
	}
}

/**
 * @brief Boucle de rendu appelée par MLX à chaque frame.
 *
 * - Met à jour la position du joueur via `move_player`.
 * - Efface l’image (`clear_image`).
 * - Dessine le sol et le plafond (`draw_floor_and_ceiling`).
 * - Dessine tous les rayons/murs (`render_rays`).
 * - Met à jour la fenêtre MLX avec l’image (`mlx_put_image_to_window`).
 *
 * @param g Pointeur vers la structure de jeu (`t_game`).
 * @return int 0 (valeur ignorée par MLX).
 */
int	draw_loop(t_game *g)
{
	move_player(&g->player, g);
	clear_image(g);
	draw_floor_and_ceiling(g);
	render_rays(g);
	mlx_put_image_to_window(g->mlx, g->win, g->data_img.img, 0, 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 10:51:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 18:46:36 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
 * @brief Vérifie si un point (px,py) tombe sur un mur (‘1’) dans la map.
 *
 * - Calcule `map_x = (int)(px/BLOCK)`, `map_y = (int)(py/BLOCK)`.
 * - Si `map_x < 0` ou `map_y < 0` ou `map_y >= nombre_de_lignes`, renvoie true.
 * - Si `map_x >= longueur_de_la_ligne`, renvoie true.
 * - Sinon, renvoie `(map[map_y][map_x] == '1')`.
 *
 * @param px   Coordonnée X (float) du point en pixels.
 * @param py   Coordonnée Y (float) du point en pixels.
 * @param game Pointeur vers la structure de jeu (`t_game`).
 * @return bool true si le point est sur un mur ou hors-carte, false sinon.
 */
bool	is_wall_point(float px, float py, t_game *game)
{
	int		map_x;
	int		map_y;
	char	**map;
	int		row_count;

	map_x = (int)(px / BLOCK);
	map_y = (int)(py / BLOCK);
	map = game->map;
	if (map_x < 0 || map_y < 0)
		return (true);
	row_count = 0;
	while (map[row_count])
		row_count++;
	if (map_y >= row_count)
		return (true);
	if (map_x >= (int)ft_strlen(map[map_y]))
		return (true);
	return (map[map_y][map_x] == '1');
}

/**
 * @brief Vérifie si une collision se produit en un point proche de (px,py).
 *
 * - Teste 4 coins autour : 
 *   (px ± COLLIDE_OFFSET, py ± COLLIDE_OFFSET).
 * - Si l’un des quatre coins est sur un mur (via `is_wall_point`), renvoie true.
 *
 * @param px   Coordonnée X (float) du point central.
 * @param py   Coordonnée Y (float) du point central.
 * @param game Pointeur vers la structure de jeu (`t_game`).
 * @return bool true si collision détectée, false sinon.
 */
bool	is_wall(float px, float py, t_game *game)
{
	return (is_wall_point(px + COLLIDE_OFFSET, py + COLLIDE_OFFSET, game)
		|| is_wall_point(px - COLLIDE_OFFSET, py + COLLIDE_OFFSET, game)
		|| is_wall_point(px + COLLIDE_OFFSET, py - COLLIDE_OFFSET, game)
		|| is_wall_point(px - COLLIDE_OFFSET, py - COLLIDE_OFFSET, game));
}


# ************************************************************************** #
#                                VARIABLES                                   #
# ************************************************************************** #

NAME        := cub3d

LIBFT_DIR   := libft
LIBFT       := $(LIBFT_DIR)/libft.a

MLX_DIR     := minilibx-linux
MLX         := $(MLX_DIR)/libmlx.a

SRC_ROOT    := src/
CORE_DIR    := $(SRC_ROOT)core/
PLAYER_DIR  := $(SRC_ROOT)player/
RAY_DIR     := $(SRC_ROOT)raycast/
GFX_DIR     := $(SRC_ROOT)graphics/
UTIL_DIR    := $(SRC_ROOT)utils/
PARSE_DIR   := $(SRC_ROOT)parse/

# files *.c
VPATH       := $(CORE_DIR) $(PLAYER_DIR) $(RAY_DIR) \
               $(GFX_DIR)  $(UTIL_DIR)  $(PARSE_DIR)

CC          := gcc
CFLAGS      := -Wall -Wextra -Werror -g
INC         := -I ./$(LIBFT_DIR)/inc -I ./inc -I $(MLX_DIR)

LDFLAGS     := -L$(LIBFT_DIR) -lft \
               -L$(MLX_DIR)   -lmlx -lXext -lX11 -lm

# Debug + Valgrind (make debug)
DEBUGGER    := valgrind --leak-check=full --show-leak-kinds=all \
               --track-origins=yes --trace-children=yes --track-fds=yes \
               --log-file=valgrind-out.txt
CFLAGS_DEBUG:= -Wuninitialized -Wmaybe-uninitialized -pedantic \
               -fsanitize=address,undefined -fno-omit-frame-pointer

GREEN := \033[1;32m
CYAN  := \033[1;36m
RESET := \033[0m

SRCS := $(foreach dir,$(VPATH),$(wildcard $(dir)*.c))
OBJS := $(SRCS:.c=.o)

all: header $(LIBFT) $(MLX) $(NAME)

header:
	@echo "$(GREEN)"
	@echo "    by         $(CYAN)@jdecarro $(GREEN)& $(CYAN)@mbendidi"
	@echo ""
	@echo "         ██████╗██╗   ██╗██████╗ ██████╗ ██████╗"
	@echo "        ██╔════╝██║   ██║██╔══██╗╚════██╗██╔══██╗"
	@echo "        ██║     ██║   ██║██████╔╝ █████╔╝██║  ██║"
	@echo "        ██║     ██║   ██║██╔══██╗ ╚═══██╗██║  ██║"
	@echo "        ╚██████╗╚██████╔╝██████╔╝██████╔╝██████╔╝"
	@echo "         ╚═════╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚═════╝"
	@echo "$(RESET)"

$(LIBFT):
	@$(MAKE) -C $(LIBFT_DIR)

$(MLX):
	@$(MAKE) -C $(MLX_DIR)

$(NAME): $(OBJS) $(LIBFT) $(MLX)
	$(CC) $(CFLAGS) $(INC) -o $@ $^ $(LDFLAGS)

%.o: %.c
	$(CC) $(CFLAGS) $(INC) -c $< -o $@

debug: CFLAGS += $(CFLAGS_DEBUG)
debug: re
	$(DEBUGGER) ./$(NAME)

clean:
	@$(MAKE) -C $(LIBFT_DIR) clean
	@$(MAKE) -C $(MLX_DIR) clean
	@rm -f $(OBJS)
	@echo "$(CYAN)Clean completed!$(RESET)"

fclean: clean
	@$(MAKE) -C $(LIBFT_DIR) fclean
	@rm -f $(MLX_DIR)/libmlx*.a
	@rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re debug header
