#ifndef CUB3D
# define CUB3D


# include <unistd.h>
# include <stdio.h>
# include <stdlib.h>
# include <mlx.h>
# include <libft.h>
# include <fcntl.h>

# define ERR_OPEN_FILE "Error\nImpossible d'ouvrir le fichier: "
# define ERR_MEM_ALLOC_TEXTURE "Error\nÉchec de l'allocation mémoire pour textures.\n"
# define ERR_EMPTY_TEXTURE_PATH "Error\nChemin de texture vide.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_NO "Error\nTexture NO déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_NO "Error\nÉchec de l'allocation mémoire pour texture NO.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_SO "Error\nTexture SO déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_SO "Error\nÉchec de l'allocation mémoire pour texture SO.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_WE "Error\nTexture WE déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_WE "Error\nÉchec de l'allocation mémoire pour texture WE.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_EA "Error\nTexture EA déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_EA "Error\nÉchec de l'allocation mémoire pour texture EA.\n"
# define ERR_MEM_ALLOC_COLOR "Error\nÉchec de l'allocation mémoire pour couleur.\n"
# define ERR_INVALID_COLOR_FORMAT "Error: Invalid color format (need exactly 3 values)\n"
# define ERR_INVALID_COLOR_VALUE "Couleur invalide: %d\n"
# define ERR_UNKNOWN_COLOR_IDENTIFIER "Identifiant de couleur inconnu \n"

typedef struct s_config
{
	char		*no_textures;
	char		*so_textures;
	char		*we_textures;
	char		*ea_textures;
	int			color_sol[3];
	int			color_plafond[3];
} t_config;

typedef struct s_game
{
	void		*mlx;
	void		*win;
	char		**map;
	t_config	config;
} t_game;

int				close_window(t_game *game);
int				key_press(int keycode, t_game *game);
void 			init_config_game(t_game *game);
int				ft_parse(t_game *game ,char *file_name);
void 			ft_split_three(t_game *game, char *clean_line, char *trimed);
void 			append_map_line(t_game *game, char *clean_line);
void			check_validate_map(t_game *game);
void			free_split(char **tokens);
int				is_integer(char *str);
void			error_and_exit(char *msg);
void			error_and_exit_free(char **tokens, char *msg);
void			check_color_value(int value);
void 			check_access(char *trimmed, char *clean_line);
void 			final_check_config(t_game *game);

#endif


# include "cub3d.h"

int	close_window(t_game *game)
{
	mlx_destroy_window(game->mlx, game->win);
	mlx_destroy_display(game->mlx);
	free(game->mlx);
	exit(0);
}#include "cub3d.h"

void error_and_exit(char *msg)
{
    ft_putstr_fd("Error\n", 2);
    ft_putstr_fd(msg, 2);
    exit(EXIT_FAILURE);
}

void	error_and_exit_free(char **tokens, char *msg)
{
	free_split(tokens);
	ft_putstr_fd(msg, 2);
	exit(EXIT_FAILURE);
}

// void	error_and_exit_free(void *arg, char *msg)
// {
// 	free(str);
// 	ft_putstr_fd(msg, 2);
	
// 	exit(EXIT_FAILURE);
// }

void	check_color_value(int value)
{
	if (value < 0 || value > 255)
	{
		ft_putstr_fd("Couleur invalide: ", 2);
		ft_putnbr_fd(value, 2);
		ft_putchar_fd('\n', 2);
		exit(EXIT_FAILURE);
	}
}
# include "cub3d.h"

void	free_split(char **tokens)
{
	int i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}# include "cub3d.h"

void init_config_game(t_game *game)
{
	game->mlx = NULL;
    game->win = NULL;
    game->config.no_textures = NULL;
    game->config.so_textures = NULL;
    game->config.we_textures = NULL;
    game->config.ea_textures = NULL;
    game->config.color_sol[0] = -1;
    game->config.color_plafond[0] = -1;
	game->map = NULL;
}
# include "cub3d.h"

int key_press(int keycode, t_game *game)
{
	printf("Touche appuyée : %d\n", keycode);
	if(keycode == 65307)
		close_window(game);
	// fleches
	else if(keycode == 65361)
		printf("Touche fleche gauche pressée\n");
	else if(keycode == 65363)
		printf("Touche fleche droite pressée\n");
	else if(keycode == 65362)
		printf("Touche fleche haut pressée\n");
	else if(keycode == 65364)
		printf("Touche fleche bas pressée\n");
	//touche clavier
	else if(keycode == 97)
		printf("Touche touche A(gauche) pressée\n");
	else if(keycode == 100)
		printf("Touche touche D(droit) pressée\n");
	else if(keycode == 119)
		printf("Touche touche W(haut) pressée\n");
	else if(keycode == 115)
		printf("Touche touche S(bas) pressée\n");
	return(0);
}
#include "cub3d.h"


void	print_debug(t_game *game)
{
	int i = 0;
	printf("---------- Debug Configuration ----------\n");
	printf("Textures :\n");
	printf("  NO: %s\n", game->config.no_textures);
	printf("  SO: %s\n", game->config.so_textures);
	printf("  WE: %s\n", game->config.we_textures);
	printf("  EA: %s\n", game->config.ea_textures);
	printf("Couleurs :\n");
	printf("  Sol      : %d, %d, %d\n",
		game->config.color_sol[0],
		game->config.color_sol[1],
		game->config.color_sol[2]);
	printf("  Plafond  : %d, %d, %d\n",
		game->config.color_plafond[0],
		game->config.color_plafond[1],
		game->config.color_plafond[2]);
	printf("-----------------------------------------\n");
	printf("-------map--------\n");
	while(game->map[i])
	{
		printf("%s\n", game->map[i]);
		i++;
	}
	printf("-----------------------------------------\n");
}

int main(int ac, char **av) 
{
	if (ac != 2) 
	{
		printf("Usage: ./cub3d map.cub\n");
		return (EXIT_FAILURE);
	}

	t_game	game;
	init_config_game(&game);
	if (ft_parse(&game, av[1]))
		return(1);
	print_debug(&game);
	game.mlx = mlx_init();
	if (!game.mlx) 
	{
		printf("Erreur : Init mlx\n");
		return (1);
	}
	game.win = mlx_new_window(game.mlx, 800, 600, "Cube3D");
	if (!game.win) 
	{
		printf("Erreur : new_window\n");
		mlx_destroy_display(game.mlx);
		free(game.mlx);
		return (1);
	}
	mlx_hook(game.win, 17, 0, close_window, &game);
	mlx_hook(game.win, 2, 1L<<0, key_press, &game);
	mlx_loop(game.mlx);
	return (0);
}
#include "cub3d.h"

static void	parse_color(t_game *game, char *clean_line, char *color_str)
{
	char	**tokens;
	int		tok_cnt;
	int		i;

	tokens = ft_split(color_str, ',');
	if (!tokens)
		error_and_exit(ERR_MEM_ALLOC_COLOR);
	tok_cnt = 0;
	while(tokens[tok_cnt])
		tok_cnt++;
	if(tok_cnt != 3)
		error_and_exit_free(tokens, ERR_INVALID_COLOR_FORMAT);
	i = 0;
	while (i < 3)
	{
		if (!tokens[i])
			error_and_exit_free(tokens, "Format de couleur invalide\n");
		i++;
	}
	i = 0;
	if (!ft_strncmp(clean_line, "F ", 2))
	{
		if (game->config.color_sol[0] != -1)
		{
			printf("%ls\n", game->config.color_plafond);
			printf("%ls\n", game->config.color_sol);
			ft_putstr_fd("Error\n =====Couleur déjà définie.\n", 2);
			free(clean_line);
			exit(EXIT_FAILURE);
		}
		while (i < 3)
		{
			game->config.color_sol[i] = ft_atoi(tokens[i]);
			check_color_value(game->config.color_sol[i]);
			i++;
		}
	}
	else if (!ft_strncmp(clean_line, "C ", 2))
	{
		if (game->config.color_plafond[0] != -1)
		{
			printf("%ls\n", game->config.color_plafond);
			printf("%ls\n", game->config.color_sol);
			ft_putstr_fd("Error\n =====Couleur déjà définie.\n", 2);
			free(clean_line);
			exit(EXIT_FAILURE);
		}
		while (i < 3)
		{
			game->config.color_plafond[i] = ft_atoi(tokens[i]);
			check_color_value(game->config.color_plafond[i]);
			i++;
		}
	}
	else
	{
		free_split(tokens);
		error_and_exit(ERR_UNKNOWN_COLOR_IDENTIFIER);
	}
	free_split(tokens);
}

int	ft_parse(t_game *game, char *file_name)
{
	int		fd;
	char	*line;
	char	*trimmed;
	char	*clean_line;

	fd = open(file_name, O_RDONLY);
	if (fd == -1)
	{
		ft_putstr_fd("Error\nImpossible d'ouvrir le fichier: ", 2);
		ft_putstr_fd(file_name, 2);
		ft_putstr_fd("\n", 2);
		return (1);
	}
	while ((line = get_next_line(fd)) != NULL)
	{
		clean_line = ft_strtrim(line, " \t\n");
		free(line);
		if (clean_line && ft_strlen(clean_line) > 0)
		{
			if (!ft_strncmp(clean_line, "NO ", 3) || !ft_strncmp(clean_line, "SO ", 3) ||
				!ft_strncmp(clean_line, "WE ", 3) || !ft_strncmp(clean_line, "EA ", 3))
			{
				trimmed = ft_strtrim(clean_line + 3, " \t\n");
				if (trimmed == NULL)
				{
					ft_putstr_fd("Error\nÉchec de l'allocation mémoire pour textures.\n", 2);
					free(clean_line);
					exit(EXIT_FAILURE);
				}
				if (ft_strlen(trimmed) == 0)
				{
					ft_putstr_fd("Error\nChemin de texture vide.\n", 2);
					free(trimmed);
					free(clean_line);
					exit(EXIT_FAILURE);
				}
				check_access(trimmed, clean_line);
				/////////////////
				if (!ft_strncmp(clean_line, "NO ", 3))
				{
					if (game->config.no_textures != NULL)
					{
						ft_putstr_fd("Error\nTexture NO déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
					game->config.no_textures = ft_strdup(trimmed);
					if (game->config.no_textures == NULL)
					{
						ft_putstr_fd("Error\nÉchec de l'allocation mémoire pour texture NO.\n", 2);
						free(trimmed);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
				}
				else if (!ft_strncmp(clean_line, "SO ", 3))
				{
					if (game->config.so_textures != NULL)
					{
						ft_putstr_fd("Error\nTexture SO déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
					game->config.so_textures = ft_strdup(trimmed);
					if (game->config.so_textures == NULL)
					{
						ft_putstr_fd("Error\nTexture SO déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
				}
				else if (!ft_strncmp(clean_line, "WE ", 3))
				{
					if (game->config.we_textures != NULL)
					{
						ft_putstr_fd("Error\nTexture WE déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
					game->config.we_textures = ft_strdup(trimmed);
					if (game->config.we_textures == NULL)
					{
						ft_putstr_fd("Error\nTexture WE déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
				}
				else if (!ft_strncmp(clean_line, "EA ", 3))
				{
					if (game->config.ea_textures != NULL)
					{
						ft_putstr_fd("Error\nTexture EA déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
					game->config.ea_textures = ft_strdup(trimmed);
					if (game->config.ea_textures == NULL)
					{
						ft_putstr_fd("Error\nTexture EA déjà définie.\n", 2);
						free(clean_line);
						exit(EXIT_FAILURE);
					}
				}
				printf("Chemin texture: %s\n", trimmed);
				free(trimmed);
			}
			else if (!ft_strncmp(clean_line, "F ", 2) ||
					 !ft_strncmp(clean_line, "C ", 2))
			{
				trimmed = ft_strtrim(clean_line + 2, " \t\n");
				if (!trimmed)
				{
					ft_putstr_fd("Error\nÉchec de l'allocation mémoire pour couleur.\n", 2);
					free(clean_line);
					close(fd);
					exit(EXIT_FAILURE);
				}
				parse_color(game, clean_line, trimmed);
				printf("Couleur lue: %s\n", trimmed);
				free(trimmed);
			}
			else
				append_map_line(game, ft_strdup(clean_line));
		}
		free(clean_line);
	}
	final_check_config(game);
	close(fd);
	return (0);
}
#include "cub3d.h"

int is_integer(char *str)
{
	int i;
	
	i = 0;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return 0;
		i++;
	}
	return 1;
}

void check_access(char *trimmed, char *clean_line)
{
	int fd;

	fd = open(trimmed, O_RDONLY);
	if(fd == -1)
	{
		ft_putstr_fd("Error\nfichier de texture inaccessible: ", 2);
		ft_putstr_fd(trimmed, 2);
		free(trimmed);
		free(clean_line);
		close(fd);
		exit(EXIT_FAILURE);
	}
	close(fd);
}

void final_check_config(t_game *game)
{
	if(game)
	{
		if(!game->config.no_textures)
		{
			ft_putstr_fd("Error\nTexture NO non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
		else if(!game->config.so_textures)
		{
			ft_putstr_fd("Error\nTexture SO non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
		else if(!game->config.ea_textures)
		{
			ft_putstr_fd("Error\nTexture EA non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
		else if(!game->config.we_textures)
		{
			ft_putstr_fd("Error\nTexture WE non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
		else if(game->config.color_sol[0] == -1)
		{
			ft_putstr_fd("Error\nColeur F(Sol) non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
		else if(game->config.color_plafond[0] == -1)
		{
			ft_putstr_fd("Error\nColeur C(Plaf.) non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
		else if(!game->map)
		{
			ft_putstr_fd("Error\nmap non définie.\n", 2);
			exit(EXIT_FAILURE);
		}
	}
}
# include "cub3d.h"


void	check_validate_map(t_game *game)
{

}

void	append_map_line(t_game *game, char *clean_line)
{
	int		i;
	int		cnt;
	char	**new_map;

	cnt = 0;
	if(game->map)
	{
		while(game->map[cnt])
			cnt++;
	}
	new_map = (char **)malloc(sizeof(char *) * (cnt + 2));
	if (!new_map)
	{
		perror("Erreur d'allocation pour la map.\n");
		exit(EXIT_FAILURE);
	}
	i = 0;
	if(game->map)
	{
		while(game->map[i])
		{
			new_map[i] = game->map[i];
			i++;
		}
	}
	new_map[i] = clean_line;
	new_map[i + 1] = NULL;
	if(game->map)
		free(game->map);
	game->map = new_map;
}
