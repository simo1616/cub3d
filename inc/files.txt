/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:48 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:43:03 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	close_window(t_game *game)
{
	mlx_destroy_window(game->mlx, game->win);
	mlx_destroy_display(game->mlx);
	free(game->mlx);
	exit(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   coord.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:24:03 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/02 12:10:55 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"


static bool	check_char(char c)
{
	return (c == 'N' || c == 'S' || c == 'E' || c == 'W');
}

static void	identify_char(char c, t_player *player)
{
	if(c == 'N')
		player->angle = -PI / 2; // 90°
	else if(c == 'S')
		player->angle = (PI * 3) / 2; // 270°
	else if(c == 'E')
		player->angle = 0.0; // 0°
	else if(c == 'W')
		player->angle = PI; // 180°
}

t_player get_coord(t_game *game)
{
	int	row;
	int	col;

	row = 0;
	col = 0;
	if(game->map)
	{
		while (game->map[row] != NULL)
		{
			col = 0;
			while (game->map[row][col] != '\0')
			{
				if (check_char(game->map[row][col]))
				{
					game->player.x = col * BLOCK + BLOCK / 2.0f;
					game->player.y = row * BLOCK + BLOCK / 2.0f;
					identify_char(game->map[row][col], &game->player);
					game->player.movespeed = 3.0;
					game->player.rotspeed  = 0.05;
					return (game->player);
				}
				col++;
			}
			row++;
		}

	}
	return(game->player);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   graphics.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:49 by jdecarro          #+#    #+#             */
/*   Updated: 2025/04/30 11:03:49 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	put_pixel(int x, int y, int color, t_game *game)
{
	int	index;

	if (x >= WIDTH || y >= HEIGHT || x < 0 || y < 0)
		return;
	index = y * game->data_img.size_line + x; //* (game->data_img.bpp / 8);
	// game->data_img.addr[index] = color & 0xFF;
	// game->data_img.addr[index + 1] = (color >> 8) & 0xFF;
	// game->data_img.addr[index + 2] = (color >> 16) & 0xFF;
	game->data_img.pixels[index] = color;
}

void	clear_image(t_game *game)
{
	int	y = 0;
	int	x = 0;

	for(y = 0; y < HEIGHT; y++)
		for(x = 0; x < WIDTH; x++)
			put_pixel(x, y, 0x00000000, game);
}

void	draw_square(int x, int y, int size, int color, t_game *game)
{
	for (int i = 0; i < size; i++)
	{
		put_pixel(x + i, y, color, game);
		put_pixel(x + i, y + size, color, game);
		put_pixel(x, y + i, color, game);
		put_pixel(x + size, y + i, color, game);
	}
}

/* void	draw_map(t_game *game)
{
	char	**map = game->map;
	int		color = 0x0000FF;
	for (int y = 0; map[y]; y++)
		for (int x = 0; map[y][x]; x++)
			if (map[y][x] == '1')
				draw_square(x * BLOCK, y * BLOCK, BLOCK, color, game);
} */

// Affiche les murs de la map en petits carrés
void draw_map(t_game *game)
{
	for (int row = 0; game->map[row]; row++)
		for (int col = 0; game->map[row][col]; col++)
			if (game->map[row][col] == '1')
				draw_square(col * BLOCK, row * BLOCK, BLOCK, 0x0000FF, game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_game.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:37:16 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/03 10:04:23 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/* void	init_config_game(t_game *game)
{
	game->mlx = NULL;
	game->win = NULL;
	game->img = NULL;
	game->config.no_textures = NULL;
	game->config.so_textures = NULL;
	game->config.we_textures = NULL;
	game->config.ea_textures = NULL;
	game->config.color_sol[0] = -1;
	game->config.color_plafond[0] = -1;
	game->map = NULL;
	game->player.x = 0.0;
	game->player.y = 0.0;
	game->player.angle = 0.0;
	game->player.movespeed = 0.0;
	game->player.rotspeed = 0.0;
} */

void init_structs(t_game *game)
{
    int i;

    game->mlx = NULL;
    game->win = NULL;

    game->data_img.img      = NULL;
    game->data_img.pixels     = NULL;
    game->data_img.bpp      = 0;
    game->data_img.size_line = 0;
    game->data_img.endian   = 0;

    game->config.no_texture = NULL;
    game->config.so_texture = NULL;
    game->config.we_texture = NULL;
    game->config.ea_texture = NULL;

    // Couleurs : on initialise TOUT le tableau à -1
    for (i = 0; i < 3; i++)
    {
        game->config.floor_color[i]   = -1;
        game->config.ceiling_color[i] = -1;
    }

    game->map = NULL;

    game->player.x = WIDTH / 2;
    game->player.y = HEIGHT / 2;
    game->player.angle = -PI / 2;
    game->player.movespeed = MOVE_SPEED;
    game->player.rotspeed = ROT_SPEED;

	game->player.key_up = false;
	game->player.key_down = false;
	game->player.key_left = false;
	game->player.key_right = false;
	game->player.left_rotate = false;
	game->player.right_rotate = false;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:05 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/30 15:59:55 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/* void	print_debug(t_game *game)
{
	int	i;

	i = 0;
	printf("---------- Debug Configuration ----------\n");
	printf("Textures :\n");
	printf("  NO: %s\n", game->config.no_textures);
	printf("  SO: %s\n", game->config.so_textures);
	printf("  WE: %s\n", game->config.we_textures);
	printf("  EA: %s\n", game->config.ea_textures);
	printf("Couleurs :\n");
	printf("  Sol      : %d, %d, %d\n", game->config.color_sol[0],
		game->config.color_sol[1], game->config.color_sol[2]);
	printf("  Plafond  : %d, %d, %d\n", game->config.color_plafond[0],
		game->config.color_plafond[1], game->config.color_plafond[2]);
	printf("-----------------------------------------\n");
	printf("-------map--------\n");
	while (game->map[i])
	{
		printf("%s\n", game->map[i]);
		i++;
	}
	printf("-----------------------------------------\n");
}

int	main(int ac, char **av)
{
	t_game	game;

	if (ac != 2)
	{
		printf("Usage: ./cub3d map.cub\n");
		return (EXIT_FAILURE);
	}
	init_config_game(&game);
	if (ft_parse(&game, av[1]))
		return (EXIT_FAILURE);
	//print_debug(&game);
	if(start_mlx(&game))
		return (EXIT_FAILURE);
	cleanup_before_exit(&game);
	return (EXIT_SUCCESS);
} */

static int  print_usage(void)
{
	ft_printf("Usage: ./cub3d <map.cub>\n");
	return (EXIT_FAILURE);
}

int main(int ac, char **av)
{
	t_game game;

	printf("[1] Après déclaration de game\n");
	if (ac != 2)
		return (print_usage());
	printf("[2] Après init_config_game\n");
	init_structs(&game);
	if (ft_parse(&game, av[1]))
		return (EXIT_FAILURE);
	printf("[3] Après parsing, map chargée\n");
	/* if (DEBUG)
		print_debug(&game); */
	printf("[4] Avant start_mlx\n");
	if (start_mlx(&game) == 0)
		return (EXIT_FAILURE);
	printf("[5] Après start_mlx (ça ne devrait jamais s’afficher avant exit)\n");
	cleanup_before_exit(&game);
	return (EXIT_SUCCESS);
}
#include "cub3d.h"

void	init_player(t_player *player)
{
	player->x = WIDTH / 2;
	player->y = HEIGHT / 2;
	player->angle = -PI / 2;
	player->movespeed = MOVE_SPEED;
	player->rotspeed = ROT_SPEED;

	player->key_up = false;
	player->key_down = false;
	player->key_left = false;
	player->key_right = false;

	player->left_rotate = false;
	player->right_rotate = false;
}

int	key_press(int keycode, t_player *player)
{
	if (keycode == W)
		player->key_up = true;
	if (keycode == S)
		player->key_down = true;
	if (keycode == A)
		player->key_left = true;
	if (keycode == D)
		player->key_right = true;
	if (keycode == LEFT)
		player->left_rotate = true;
	if (keycode == RIGHT)
		player->right_rotate = true;
	if (keycode == KEY_ESC || keycode == KEY_Q)
		exit(0);
	return (0);
}

int	key_release(int keycode, t_player *player)
{
	if (keycode == W)
		player->key_up = false;
	if (keycode == S)
		player->key_down = false;
	if (keycode == A)
		player->key_left = false;
	if (keycode == D)
		player->key_right = false;
	if (keycode == LEFT)
		player->left_rotate = false;
	if (keycode == RIGHT)
		player->right_rotate = false;
	return (0);
}

void move_player(t_player *player, t_game *game)
{
    float speed      = player->movespeed;
    float angle_speed= player->rotspeed;
    float new_x;
    float new_y;

    /* rotation */
    if (player->left_rotate)
        player->angle -= angle_speed;
    if (player->right_rotate)
        player->angle += angle_speed;
    if (player->angle < 0)
        player->angle += 2 * PI;
    else if (player->angle >= 2 * PI)
        player->angle -= 2 * PI;

    /* déplacement avant/arrière */
    if (player->key_up || player->key_down)
    {
        float dir = (player->key_up ? 1.0f : -1.0f);
        new_x = player->x + cosf(player->angle) * speed * dir;
        new_y = player->y + sinf(player->angle) * speed * dir;

        /* on teste X et Y séparément pour slippage si besoin */
        if (!is_wall(new_x, player->y, game))
            player->x = new_x;
        if (!is_wall(player->x, new_y, game))
            player->y = new_y;
    }

    /* déplacement latéral A/D */
    if (player->key_left || player->key_right)
    {
        float dir = (player->key_right ? 1.0f : -1.0f);
        /* strafe = angle + 90° */
        float strafe_angle = player->angle + (dir * PI/2);
        new_x = player->x + cosf(strafe_angle) * speed;
        new_y = player->y + sinf(strafe_angle) * speed;
        if (!is_wall(new_x, player->y, game))
            player->x = new_x;
        if (!is_wall(player->x, new_y, game))
            player->y = new_y;
    }
}



/* 	if (player->key_up)
		printf("W\n");
	if (player->key_down)
		printf("S\n");
	if (player->key_left)
		printf("A\n");
	if (player->key_right)
		printf("D\n");
 */

/* 	if (player->x < 0)
		player->x = 0;
	if (player->x > WIDTH - 20)
		player->x = WIDTH - 20;
	if (player->y < 0)
		player->y = 0;
	if (player->y > HEIGHT - 20)
		player->y = HEIGHT - 20; */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/04/30 11:03:27 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

// static bool	touch(float px, float py, t_game *game)
// {
// 	int	x = px / BLOCK;
// 	int	y = py / BLOCK;
// 	if (x < 0 || y < 0 || !game->map[y] || game->map[y][x] != '1')
// 		return (false);
// 	return (true);
// }

static float distance(float x, float y)
{
	return (sqrt(x * x + y * y));
}

static float fixed_dist(float x1, float y1, float x2, float y2, t_game *game)
{
	float delta_x = x2 - x1;
	float delta_y = y2 - y1;
	float angle = atan2(delta_y, delta_x) - game->player.angle;
	float fix_dist = distance(delta_x, delta_y) * cos(angle);
	return (fix_dist);
}

void	draw_line(t_player *player, t_game *game, float start_x, int i)
{
	float ray_x = player->x;
	float ray_y = player->y;
	float cos_angle = cosf(start_x);
	float sin_angle = sinf(start_x);

	while (!is_wall(ray_x, ray_y, game))
	{
		if (DEBUG)
			put_pixel(ray_x, ray_y, 0xFF0000, game);
		ray_x += cos_angle;
		ray_y += sin_angle;
	}
	if (!DEBUG)
	{
		/* float dist = distance(ray_x - player->x, ray_y - player->y); */
		// controlling eye fishing effect
		float dist = fixed_dist(player->x, player->y, ray_x, ray_y, game);
		float height = (BLOCK / dist) * (WIDTH / 2);
		int start_y = (HEIGHT - height) / 2;
		int end = start_y + height;
		while (start_y < end)
		{
			put_pixel(i, start_y, 0xFFFFFF, game);
			start_y++;
		}
	}
}

int	draw_loop(t_game *game)
{
	t_player	*player;
	float		fov;
	float		half_fov;
	float		ray_angle;
	int			i;

	player = &game->player;
	fov = FOV_ANGLE; // 60°
	half_fov = fov * 0.5f; // 30°
	i = 0;
	move_player(&game->player, game);
	clear_image(game); 
	if (DEBUG)
	{
		draw_square(player->x, player->y, 20, 0x00FF00, game);
		draw_map(game);
	}
	// float	fraction = PI / 3 / WIDTH;
	// float	start_x = player->angle - PI / 6;
	// int		i = 0;
	while (i < WIDTH)
	{
		ray_angle = player->angle - half_fov + ((float)i * fov / (float)WIDTH);
		if (ray_angle < 0)
			ray_angle += 2 * PI;
		else if (ray_angle >= 2 * PI)
			ray_angle -= 2 * PI;
		draw_line(player, game, ray_angle, i);
		//cast_single_ray(player, game, ray_angle, i);
		//start_x += fraction;
		i++;
	}

	mlx_put_image_to_window(game->mlx, game->win, game->data_img.img, 0, 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_mlx.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:10:47 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/03 10:03:21 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	start_mlx(t_game *game)
{
	char	*addr;
	
	game->mlx = mlx_init();
	printf("[start_mlx] mlx_init ok: %p\n", game->mlx);
	if (!game->mlx)
	{
		printf("Erreur : Init mlx\n");
		return (-1);
	}
	game->win = mlx_new_window(game->mlx, WIDTH, HEIGHT, "Cub3D");
	printf("[start_mlx] new_window ok: %p\n", game->win);
	if (!game->win)
	{
		printf("Erreur : new_window\n");
		mlx_destroy_display(game->mlx);
		free(game->mlx);
		return (-1);
	}
	game->data_img.img = mlx_new_image(game->mlx, WIDTH, HEIGHT);
	printf("[start_mlx] new_image ok: %p\n", game->data_img.img);
	if (!game->data_img.img)
	{
		printf("Erreur : new_img\n");
		mlx_destroy_window(game->mlx, game->win);
		mlx_destroy_display(game->mlx);
		free(game->mlx);
		return (-1);
	}
	addr = mlx_get_data_addr(game->data_img.img, &game->data_img.bpp, &game->data_img.size_line,&game->data_img.endian);
	game->data_img.pixels = (int *)addr;
	game->data_img.size_line /= (game->data_img.bpp / 8);
	game->player = get_coord(game);

	mlx_hook(game->win, 2, 1L<<0, key_press, &game->player);
	mlx_hook(game->win, 3, 1L<<1, key_release, &game->player);
	mlx_hook(game->win, 17, 0, close_window, game);

	mlx_loop_hook(game->mlx, draw_loop, game);
	mlx_loop(game->mlx);
	return(1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 10:51:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/03 11:47:09 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static bool is_wall_point(float px, float py, t_game *game)
{
    int   map_x = (int)(px / BLOCK);
    int   map_y = (int)(py / BLOCK);
    char **map   = game->map;
    int   row_count;

    /* 1) Hors limites négatifs => mur */
    if (map_x < 0 || map_y < 0)
        return (true);

    /* 2) Comptage des lignes pour le test en Y */
    row_count = 0;
    while (map[row_count])
        row_count++;

    /* 3) Hors limites bas => mur */
    if (map_y >= row_count)
        return (true);

    /* 4) Hors limites droite => mur */
    if (map_x >= (int)ft_strlen(map[map_y]))
        return (true);

    /* 5) Cas normal : mur si le caractère est '1' */
    return (map[map_y][map_x] == '1');
}

bool is_wall(float px, float py, t_game *game)
{
    /* on teste quatre points autour du joueur */
    return (is_wall_point(px + COLLIDE_OFFSET, py + COLLIDE_OFFSET, game) ||
           is_wall_point(px - COLLIDE_OFFSET, py + COLLIDE_OFFSET, game) ||
           is_wall_point(px + COLLIDE_OFFSET, py - COLLIDE_OFFSET, game) ||
           is_wall_point(px - COLLIDE_OFFSET, py - COLLIDE_OFFSET, game));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cub3d.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 09:33:13 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/03 11:40:49 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CUB3D_H
# define CUB3D_H

# include "../minilibx-linux/mlx.h"
# include "parser_cub3d.h"
# include <math.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>

#define WIDTH 800
#define HEIGHT 600
#define IMG_W 800
#define IMG_H 600
#define BLOCK 64
#define DEBUG 0
#define COLLIDE_OFFSET 5.0f

#define MOVE_SPEED 3.0f
#define ROT_SPEED 0.05f

# define W	119 //122
# define S	 115//115
# define A	97//113
# define D	100//100
# define LEFT			65361
# define RIGHT			65363

# define KEY_Q			113//97
# define KEY_ESC		65307

# define PI 3.14159265359
# define FOV_ANGLE   (60.0f * (PI / 180.0f))

typedef struct s_data_img
{
	void	*img;
	//char	*addr;
	int		*pixels;
	int		bpp;
	int		size_line;
	int		endian;
}	t_data_img;

typedef struct s_player {
    float x;
    float y;
    float angle;     // orientation 
    float movespeed; // vitesse de déplacement
    float rotspeed;  // vitesse de rotation

	bool	key_up;
	bool	key_down;
	bool	key_left;
	bool	key_right;

	bool	left_rotate;
	bool	right_rotate;
} t_player;

typedef struct s_config {
	char	*no_texture;
	char	*so_texture;
	char	*we_texture;
	char	*ea_texture;

	int		floor_color[3];
	int		ceiling_color[3];
} t_config;

typedef struct s_game {
	void		*mlx;
	void		*win;
	char		**map;

	t_config	config;
	t_player	player;
	t_data_img	data_img;
} t_game;


int			start_mlx(t_game *game);
t_player 	get_coord(t_game *game);

void	init_player(t_player *player);
int		key_press(int keycode, t_player *player);
int		key_release(int keycode, t_player *player);
void 	move_player(t_player *player, t_game *game);

void	put_pixel(int x, int y, int color, t_game *game);
void	clear_image(t_game *game);
void	draw_square(int x, int y, int size, int color, t_game *game);
void	 draw_map(t_game *game);

void	draw_line(t_player *player, t_game *game, float start_x, int i);
int		draw_loop(t_game *game);

void 	init_structs(t_game *game);
bool 	is_wall(float px, float py, t_game *g);


#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_cub3d.h                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 09:33:09 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/03 09:33:10 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSER_CUB3D_H
# define PARSER_CUB3D_H

# include <unistd.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>
# include <mlx.h>
# include <libft.h>
# include <fcntl.h>

/* ===================== CONSTANTES ERREURS ===================== */

# define ERR_OPEN_FILE "Error\nImpossible d'ouvrir le fichier: "
# define ERR_MEM_ALLOC_TEXTURE "Error\nÉchec de l'allocation mémoire pour textures.\n"
# define ERR_EMPTY_TEXTURE_PATH "Error\nChemin de texture vide.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_NO "Error\nTexture NO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_SO "Error\nTexture SO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_WE "Error\nTexture WE déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_EA "Error\nTexture EA déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_NO "Error\nÉchec de l'allocation mémoire pour texture NO.\n"
# define ERR_MEM_ALLOC_TEXTURE_SO "Error\nÉchec de l'allocation mémoire pour texture SO.\n"
# define ERR_MEM_ALLOC_TEXTURE_WE "Error\nÉchec de l'allocation mémoire pour texture WE.\n"
# define ERR_MEM_ALLOC_TEXTURE_EA "Error\nÉchec de l'allocation mémoire pour texture EA.\n"
# define ERR_MEM_ALLOC_COLOR "Error\nÉchec de l'allocation mémoire pour couleur.\n"
# define ERR_INVALID_COLOR_FORMAT "Error\nInvalid color format (need exactly 3 values)\n"
# define ERR_INVALID_COLOR_VALUE "Error\nCouleur invalide: \n"
# define ERR_UNKNOWN_COLOR_IDENTIFIER "Error\nIdentifiant de couleur inconnu \n"
# define ERR_MAP_FIRST_LAST_LINE "Error\nLigne (1ère/dernière) contient autre chose que '1'.\n"
# define ERR_MAP_START_LINE "Error\nUne ligne ne commence pas par un mur '1'.\n"
# define ERR_TEXTURE_NOT_DEFINED_NO "Error\nTexture NO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_SO "Error\nTexture SO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_WE "Error\nTexture WE non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_EA "Error\nTexture EA non définie.\n"
# define ERR_COLOR_NOT_DEFINED_F "Error\nCouleur F(Sol) non définie.\n"
# define ERR_COLOR_NOT_DEFINED_C "Error\nCouleur C(Plaf.) non définie.\n"
# define ERR_MAP_NOT_DEFINED "Error\nMap non définie.\n"
# define ERR_MAP_EMPTY "Error\nMap vide.\n"
# define ERR_MAP_INVALID_CHAR "Error\nCaractère invalide.\n"
# define ERR_MAP_TEXT_MORE_THAN_ONE "Error\nIl faut exactement 1 orientation (N,S,E,W).\n"
# define ERR_MAP_MALLOC "Error\nMalloc failed for visited.\n"
# define ERR_MAP_NOT_CLOSE "Error\nMap non fermée (fuite détectée)\n"
# define ERR_MAP_BAD "Error\nDes caractères trouvés après des lignes vides suivant la carte.\n"
# define ERR_MAP_POS "Error\nPosition de la map incorrecte (pas toutes les textures/couleurs lues).\n"
# define ERR_MAP_ADD "Error\nDes données supp après la carte.\n"

/* ===================== STRUCTURES ===================== */

typedef struct s_config t_config;
typedef struct s_game t_game;

typedef enum e_parse_state {
	READING_CONFIG,
	READING_MAP,
	MAP_DONE
} t_parse_state;

typedef struct s_mapinfo {
	char	**map2d;
	bool	**visited;
	int		width;
	int		height;
} t_mapinfo;

typedef struct s_player_data {
	int		*count;
	int		*row;
	int		*col;
	t_mapinfo *info;
} t_player_data;

typedef struct s_cleanup_state {
	bool game_cleaned;
	bool parser_cleaned;
} t_cleanup_state;

typedef struct s_parser {
	int				fd;
	char			*line;
	char			*clean_line;
	char			*trimmed;
	int				match_text;
	int				match_color;
	bool			map_started;
	bool			map_is_done;
	bool			empty_line_after_map;
	t_game			*game;
	t_cleanup_state	*state;
} t_parser;

typedef struct s_line_info {
	int row;
	int first;
	int last;
} t_line_info;

/* ===================== FONCTIONS PRINCIPALES ===================== */

int				close_window(t_game *game);
void			init_structs(t_game *game);
int				ft_parse(t_game *game, char *filename);

/* ===================== FONCTIONS DE PARSING ===================== */

void			parse_color(t_game *game, char *clean_line, char *color_str, t_parser *parser);
void			ft_split_three(t_game *game, char *clean_line, char *trimed);
void			append_map_line(t_game *game, char *clean_line);
void			check_validate_map(t_game *game, t_parser *parser);
void			free_split(char **tokens);
int				is_integer(char *str);
void			error_and_exit(char *msg);
void			error_and_exit_free(char **tokens, char *msg);
void			check_color_value(int value, t_parser *parser);
void			check_access(t_parser *parser);
void			final_check_config(t_game *game);

/* ===================== UTILITAIRES DE PARSING ===================== */

void			init_parser(t_parser *parser, t_game *game);
int				open_map_file(char *file_name);
void			process_texture_line(t_game *game, t_parser *parser);
void			process_color_line(t_game *game, t_parser *parser);
void			process_map_line(t_game *game, t_parser *parser);
void			handle_empty_line(t_parser *parser);
void			check_map_errors(t_parser *parser);
void			assign_texture(t_game *game, t_parser *parser);
void			assign_if_not_defined(char **texture_field, char *trimmed, char *error_msg, t_parser *parser);
bool			is_only_spaces(char *line);
void			check_first_or_last_line(char *line, t_parser *parser);
void			check_middle_line(char *line, int row, t_parser *parser);
void			check_line_borders(char *line, t_line_info info, t_parser *parser);
bool			dfs_closed(t_mapinfo *info, int r, int c);
bool			is_valid_map_char(char c);
void			exit_text_with_error(char *msg, t_parser *parser);

/* ===================== GESTION DE MAP ===================== */

void			init_visited_map(t_mapinfo *info);
void			free_mapinfo(t_mapinfo *info);
int				get_map_height(char **map);
void			check_map_empty(int height);
int				get_max_width(char **map, int height);
void			init_mapinfo_struct(t_mapinfo *info, char **map, int h, int w);
void			copy_and_pad_line(char *dest, char *src, int width);

/* ===================== CLEANUP ===================== */

void			free_map(char **map);
void			free_config(t_config *config);
void			cleanup_all(t_game *game, t_parser *parser);
void			cleanup_before_exit(t_game *game);
void			cleanup_parser_resources(t_parser *parser);
void			cleanup_get_next_line(void);

#endif