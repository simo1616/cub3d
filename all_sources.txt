
===== inc/cub3d.h =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cub3d.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 09:33:13 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:51:39 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CUB3D_H
# define CUB3D_H

# include "../minilibx-linux/mlx.h"
# include "parser_cub3d.h"
# include <math.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>

#define WIDTH 800
#define HEIGHT 600
#define IMG_W 800
#define IMG_H 600
#define BLOCK 64
#define DEBUG 0
#define COLLIDE_OFFSET 5.0f
#define NBR_TEX 4

#define NORTH 0
#define SOUTH 1
#define WEST  2
#define EAST  3


#define MOVE_SPEED 1.0f
#define ROT_SPEED 0.01f

# define W	119 //122
# define S	 115//115
# define A	97//113
# define D	100//100
# define LEFT			65361
# define RIGHT			65363

# define KEY_Q			113//97
# define KEY_ESC		65307

# define PI 3.14159265359
# define FOV_ANGLE   (60.0f * (PI / 180.0f))
#define DIST_PROJ_PLANE  ( (WIDTH/2.0f) / tanf(FOV_ANGLE/2.0f) )


typedef struct s_data_img
{
	void	*img;
	//char	*addr;
	int		*pixels;
	int		bpp;
	int		size_line;
	int		endian;
}	t_data_img;

typedef struct s_player 
{
	float	x;
	float	y;
	float	angle;     // orientation 
	bool	key_up;
	bool	key_down;
	bool	key_left;
	bool	key_right;
	bool	left_rotate;
	bool	right_rotate;
} t_player;

typedef struct s_config {
	char	*no_texture;
	char	*so_texture;
	char	*we_texture;
	char	*ea_texture;
	int		floor_color[3];
	int		ceiling_color[3];
} t_config;

typedef struct s_tex
{
	void  *img;
	int   *pixels;
	int    width;
	int    height;
	int    bpp;
	int    size_line;
	int    endian;
}   t_tex;

typedef struct  s_ray
{
	int   map_x;
	int   map_y;
	float rdx;
	float rdy;
	float ddx;
	float ddy;
	float sdx;
	float sdy;
	int   sx;
	int   sy;
	int   side;
}               t_ray;

typedef struct s_vline
{
	int	x;
	int	start;
	int	end;
	int	tex_x;
}	t_vline;

typedef struct s_game {
	void		*mlx;
	void		*win;
	char		**map;
	t_config	config;
	t_player	player;
	t_data_img	data_img;
	t_tex textures[NBR_TEX]; // NO, SO, WE, EA
} t_game;



int			start_mlx(t_game *game);
t_player 	get_coord(t_game *game);

void	init_player(t_player *player);
int		key_press(int keycode, t_game *game);
int		key_release(int keycode, t_game *game);
void 	move_player(t_player *player, t_game *game);

void	put_pixel(int x, int y, int color, t_game *game);
void	clear_image(t_game *game);
void	draw_square(int x, int y, int color, t_game *game);
void	draw_map(t_game *game);

void	draw_line(t_player *p, t_game *g, float ray_ang, int x);
int		draw_loop(t_game *game);

void 	init_structs(t_game *game);
bool 	is_wall(float px, float py, t_game *g);
void	text_load(t_game *game);
bool is_wall_point(float px, float py, t_game *game);
void	cast_ray( t_player *p, float ray_ang, t_game *g, float out[2]);

#endif
===== inc/parser_cub3d.h =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_cub3d.h                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 09:33:09 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 14:16:53 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSER_CUB3D_H
# define PARSER_CUB3D_H

# include <unistd.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>
# include <mlx.h>
# include <libft.h>
# include <fcntl.h>

/* ===================== CONSTANTES ERREURS ===================== */

# define ERR_OPEN_FILE "Error\nImpossible d'ouvrir le fichier: "
# define ERR_MEM_ALLOC_TEXTURE "Error\nÉchec de l'allocation mémoire pour textures.\n"
# define ERR_EMPTY_TEXTURE_PATH "Error\nChemin de texture vide.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_NO "Error\nTexture NO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_SO "Error\nTexture SO déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_WE "Error\nTexture WE déjà définie.\n"
# define ERR_TEXTURE_ALREADY_DEFINED_EA "Error\nTexture EA déjà définie.\n"
# define ERR_MEM_ALLOC_TEXTURE_NO "Error\nÉchec de l'allocation mémoire pour texture NO.\n"
# define ERR_MEM_ALLOC_TEXTURE_SO "Error\nÉchec de l'allocation mémoire pour texture SO.\n"
# define ERR_MEM_ALLOC_TEXTURE_WE "Error\nÉchec de l'allocation mémoire pour texture WE.\n"
# define ERR_MEM_ALLOC_TEXTURE_EA "Error\nÉchec de l'allocation mémoire pour texture EA.\n"
# define ERR_MEM_ALLOC_COLOR "Error\nÉchec de l'allocation mémoire pour couleur.\n"
# define ERR_INVALID_COLOR_FORMAT "Error\nInvalid color format (need exactly 3 values)\n"
# define ERR_INVALID_COLOR_VALUE "Error\nCouleur invalide: \n"
# define ERR_UNKNOWN_COLOR_IDENTIFIER "Error\nIdentifiant de couleur inconnu \n"
# define ERR_MAP_FIRST_LAST_LINE "Error\nLigne (1ère/dernière) contient autre chose que '1'.\n"
# define ERR_MAP_START_LINE "Error\nUne ligne ne commence pas par un mur '1'.\n"
# define ERR_TEXTURE_NOT_DEFINED_NO "Error\nTexture NO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_SO "Error\nTexture SO non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_WE "Error\nTexture WE non définie.\n"
# define ERR_TEXTURE_NOT_DEFINED_EA "Error\nTexture EA non définie.\n"
# define ERR_COLOR_NOT_DEFINED_F "Error\nCouleur F(Sol) non définie.\n"
# define ERR_COLOR_NOT_DEFINED_C "Error\nCouleur C(Plaf.) non définie.\n"
# define ERR_MAP_NOT_DEFINED "Error\nMap non définie.\n"
# define ERR_MAP_EMPTY "Error\nMap vide.\n"
# define ERR_MAP_INVALID_CHAR "Error\nCaractère invalide.\n"
# define ERR_MAP_TEXT_MORE_THAN_ONE "Error\nIl faut exactement 1 orientation (N,S,E,W).\n"
# define ERR_MAP_MALLOC "Error\nMalloc failed for visited.\n"
# define ERR_MAP_NOT_CLOSE "Error\nMap non fermée (fuite détectée)\n"
# define ERR_MAP_BAD "Error\nDes caractères trouvés après des lignes vides suivant la carte.\n"
# define ERR_MAP_POS "Error\nPosition de la map incorrecte (pas toutes les textures/couleurs lues).\n"
# define ERR_MAP_ADD "Error\nDes données supp après la carte.\n"

/* ===================== STRUCTURES ===================== */

struct s_parser;
typedef struct s_config t_config;
typedef struct s_game t_game;
typedef struct s_parser  t_parser;

typedef enum e_parse_state {
	READING_CONFIG,
	READING_MAP,
	MAP_DONE
} t_parse_state;

typedef struct s_mapinfo {
	char	**map2d;
	bool	**visited;
	int		width;
	int		height;
} t_mapinfo;

typedef struct s_player_data {
	int		*count;
	int		*row;
	int		*col;
	t_mapinfo *info;
	t_parser    *parser;
} t_player_data;

typedef struct s_cleanup_state {
	bool game_cleaned;
	bool parser_cleaned;
} t_cleanup_state;

typedef struct s_parser {
	int				fd;
	char			*line;
	char			*clean_line;
	char			*trimmed;
	int				match_text;
	int				match_color;
	bool			map_started;
	bool			map_is_done;
	bool			empty_line_after_map;
	t_game			*game;
	t_cleanup_state	*state;
} t_parser;

typedef struct s_line_info {
	int row;
	int first;
	int last;
} t_line_info;

/* ===================== FONCTIONS PRINCIPALES ===================== */

int				close_window(t_game *game);
void			init_structs(t_game *game);
int				ft_parse(t_game *game, char *filename);

/* ===================== FONCTIONS DE PARSING ===================== */

void			parse_color(t_game *game, char *clean_line, char *color_str, t_parser *parser);
void			ft_split_three(t_game *game, char *clean_line, char *trimed);
void			append_map_line(t_game *game, char *clean_line);
void			check_validate_map(t_game *game, t_parser *parser);
void			free_split(char **tokens);
int				is_integer(char *str);
void			error_exit_game(t_game *game, char *msg);
void			error_and_exit(t_parser *parser, char *msg);
void			error_and_exit_free(t_parser *parser, char **tokens, char *msg);
void			check_color_value(int value, t_parser *parser);
void			check_access(t_parser *parser);
void			final_check_config(t_game *game, t_parser *parser);

/* ===================== UTILITAIRES DE PARSING ===================== */

void			init_parser(t_parser *parser, t_game *game);
int				open_map_file(char *file_name);
void			process_texture_line(t_game *game, t_parser *parser);
void			process_color_line(t_game *game, t_parser *parser);
void			process_map_line(t_game *game, t_parser *parser);
void			handle_empty_line(t_parser *parser);
void			check_map_errors(t_parser *parser);
void			assign_texture(t_game *game, t_parser *parser);
void			assign_if_not_defined(char **texture_field, char *trimmed, char *error_msg, t_parser *parser);
bool			is_only_spaces(char *line);
void			check_first_or_last_line(char *line, t_parser *parser);
void			check_middle_line(char *line, int row, t_parser *parser);
void			check_line_borders(char *line, t_line_info info, t_parser *parser);
bool			dfs_closed(t_mapinfo *info, int r, int c);
bool			is_valid_map_char(char c);
void			exit_text_with_error(char *msg, t_parser *parser);

/* ===================== GESTION DE MAP ===================== */

void			init_visited_map(t_mapinfo *info, t_parser *parser);
void			free_mapinfo(t_mapinfo *info);
int				get_map_height(char **map);
void			check_map_empty(int height);
int				get_max_width(char **map, int height);
void			init_mapinfo_struct(t_mapinfo *info, t_game *game, t_parser *parser);
void			copy_and_pad_line(char *dest, char *src, int width);

/* ===================== CLEANUP ===================== */

void			free_map(char **map);
void			free_config(t_config *config);
void			cleanup_all(t_game *game, t_parser *parser);
void			cleanup_before_exit(t_game *game);
void			cleanup_parser_resources(t_parser *parser);
void			cleanup_get_next_line(void);

#endif
===== src/key.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   key.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 12:26:11 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:17:43 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	set_player_key(int keycode, t_player *p, bool state)
{
	if (keycode == W)
		p->key_up = state;
	else if (keycode == S)
		p->key_down = state;
	else if (keycode == A)
		p->key_left = state;
	else if (keycode == D)
		p->key_right = state;
	else if (keycode == LEFT)
		p->left_rotate = state;
	else if (keycode == RIGHT)
		p->right_rotate = state;
}

int	key_press(int keycode, t_game *game)
{
	if ((keycode == KEY_ESC || keycode == KEY_Q))
	{
		cleanup_before_exit(game);
		exit(EXIT_SUCCESS);
	}
	set_player_key(keycode, &game->player, true);
	return (0);
}

int	key_release(int keycode, t_game *game)
{
	set_player_key(keycode, &game->player, false);
	return (0);
}

===== src/utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 10:51:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/04 12:56:09 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

bool	is_wall_point(float px, float py, t_game *game)
{
	int		map_x;
	int		map_y;
	char	**map;
	int		row_count;

	map_x = (int)(px / BLOCK);
	map_y = (int)(py / BLOCK);
	map = game->map;
	if (map_x < 0 || map_y < 0)
		return (true);
	row_count = 0;
	while (map[row_count])
		row_count++;
	if (map_y >= row_count)
		return (true);
	if (map_x >= (int)ft_strlen(map[map_y]))
		return (true);
	return (map[map_y][map_x] == '1');
}

bool	is_wall(float px, float py, t_game *game)
{
	return (is_wall_point(px + COLLIDE_OFFSET, py + COLLIDE_OFFSET, game)
		|| is_wall_point(px - COLLIDE_OFFSET, py + COLLIDE_OFFSET, game)
		|| is_wall_point(px + COLLIDE_OFFSET, py - COLLIDE_OFFSET, game)
		|| is_wall_point(px - COLLIDE_OFFSET, py - COLLIDE_OFFSET, game));
}

===== src/coord.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   coord.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:24:03 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:22:34 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static bool	check_char(char c)
{
	return (c == 'N' || c == 'S' || c == 'E' || c == 'W');
}

static void	identify_char(char c, t_player *player)
{
	if (c == 'N')
		player->angle = -PI / 2;
	else if (c == 'S')
		player->angle = (PI * 3) / 2;
	else if (c == 'E')
		player->angle = 0.0;
	else if (c == 'W')
		player->angle = PI;
}

t_player	get_coord(t_game *game)
{
	int	row;
	int	col;

	row = 0;
	col = 0;
	if (game->map)
	{
		while (game->map[row] != NULL)
		{
			col = 0;
			while (game->map[row][col] != '\0')
			{
				if (check_char(game->map[row][col]))
				{
					game->player.x = col * BLOCK + BLOCK / 2.0f;
					game->player.y = row * BLOCK + BLOCK / 2.0f;
					identify_char(game->map[row][col], &game->player);
					return (game->player);
				}
				col++;
			}
			row++;
		}
	}
	return (game->player);
}

===== src/raycast_render.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast_render.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 12:32:05 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	draw_ceiling(t_game *g, int col)
{
	int	y;
	int	x;

	y = 0;
	while (y < HEIGHT / 2)
	{
		x = 0;
		while (x < WIDTH)
		{
			put_pixel(x, y, col, g);
			x++;
		}
		y++;
	}
}

static void	draw_floor(t_game *g, int col)
{
	int	y;
	int	x;

	y = HEIGHT / 2;
	while (y < HEIGHT)
	{
		x = 0;
		while (x < WIDTH)
		{
			put_pixel(x, y, col, g);
			x++;
		}
		y++;
	}
}

static void	draw_floor_and_ceiling(t_game *g)
{
	int	ceil_col;
	int	floor_col;

	ceil_col = (g->config.ceiling_color[0] << 16)
		| (g->config.ceiling_color[1] << 8)
		| g->config.ceiling_color[2];
	floor_col = (g->config.floor_color[0] << 16)
		| (g->config.floor_color[1] << 8)
		| g->config.floor_color[2];
	draw_ceiling(g, ceil_col);
	draw_floor(g, floor_col);
}

static void	render_rays(t_game *g)
{
	t_player	*p;
	float		fov;
	float		half;
	int			i;
	float		ang;

	p = &g->player;
	fov = FOV_ANGLE;
	half = fov * 0.5f;
	i = 0;
	while (i < WIDTH)
	{
		ang = p->angle - half + (i * fov / (float)WIDTH);
		if (ang < 0)
			ang += 2 * PI;
		else if (ang >= 2 * PI)
			ang -= 2 * PI;
		draw_line(p, g, ang, i);
		i++;
	}
}

int	draw_loop(t_game *g)
{
	move_player(&g->player, g);
	clear_image(g);
	draw_floor_and_ceiling(g);
	render_rays(g);
	mlx_put_image_to_window(g->mlx, g->win, g->data_img.img, 0, 0);
	return (0);
}

===== src/main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:05 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:35:26 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/* void	print_debug(t_game *game)
{
	int	i;

	i = 0;
	printf("---------- Debug Configuration ----------\n");
	printf("Textures :\n");
	printf("  NO: %s\n", game->config.no_textures);
	printf("  SO: %s\n", game->config.so_textures);
	printf("  WE: %s\n", game->config.we_textures);
	printf("  EA: %s\n", game->config.ea_textures);
	printf("Couleurs :\n");
	printf("  Sol      : %d, %d, %d\n", game->config.color_sol[0],
		game->config.color_sol[1], game->config.color_sol[2]);
	printf("  Plafond  : %d, %d, %d\n", game->config.color_plafond[0],
		game->config.color_plafond[1], game->config.color_plafond[2]);
	printf("-----------------------------------------\n");
	printf("-------map--------\n");
	while (game->map[i])
	{
		printf("%s\n", game->map[i]);
		i++;
	}
	printf("-----------------------------------------\n");
}

int	main(int ac, char **av)
{
	t_game	game;

	if (ac != 2)
	{
		printf("Usage: ./cub3d map.cub\n");
		return (EXIT_FAILURE);
	}
	init_config_game(&game);
	if (ft_parse(&game, av[1]))
		return (EXIT_FAILURE);
	//print_debug(&game);
	if(start_mlx(&game))
		return (EXIT_FAILURE);
	cleanup_before_exit(&game);
	return (EXIT_SUCCESS);
} */
static int	print_usage(void)
{
	ft_printf("Usage: ./cub3d <map.cub>\n");
	return (EXIT_FAILURE);
}

int	main(int ac, char **av)
{
	t_game	game;

	if (ac != 2)
		return (print_usage());
	init_structs(&game);
	if (ft_parse(&game, av[1]))
		return (EXIT_FAILURE);
	if (start_mlx(&game) == 0)
	{
		cleanup_before_exit(&game);
		return (EXIT_FAILURE);
	}
	cleanup_before_exit(&game);
	return (EXIT_SUCCESS);
}

===== src/player.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   player.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/31 12:37:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:37:19 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	init_player(t_player *player)
{
	player->x = WIDTH / 2;
	player->y = HEIGHT / 2;
	player->angle = -PI / 2;
	player->key_up = false;
	player->key_down = false;
	player->key_left = false;
	player->key_right = false;
	player->left_rotate = false;
	player->right_rotate = false;
}

static void	rotate_player(t_player *player)
{
	if (player->left_rotate)
		player->angle -= ROT_SPEED;
	if (player->right_rotate)
		player->angle += ROT_SPEED;
	if (player->angle < 0)
		player->angle += 2 * PI;
	else if (player->angle >= 2 * PI)
		player->angle -= 2 * PI;
}

static void	translate_player(t_player *player, t_game *game)
{
	float	new_x;
	float	new_y;
	float	dir;

	if (player->key_up || player->key_down)
	{
		if (player->key_up)
			dir = 1.0f;
		else
			dir = -1.0f;
		new_x = player->x + cosf(player->angle) * MOVE_SPEED * dir;
		new_y = player->y + sinf(player->angle) * MOVE_SPEED * dir;
		if (!is_wall(new_x, player->y, game))
			player->x = new_x;
		if (!is_wall(player->x, new_y, game))
			player->y = new_y;
	}
}

static void	strafe_player(t_player *player, t_game *game)
{
	float	new_x;
	float	new_y;
	float	dir;

	if (player->key_left || player->key_right)
	{
		if (player->key_right)
			dir = 1.0f;
		else
			dir = -1.0f;
		new_x = player->x + cosf(player->angle + dir * PI / 2) * MOVE_SPEED;
		new_y = player->y + sinf(player->angle + dir * PI / 2) * MOVE_SPEED;
		if (!is_wall(new_x, player->y, game))
			player->x = new_x;
		if (!is_wall(player->x, new_y, game))
			player->y = new_y;
	}
}

void	move_player(t_player *player, t_game *game)
{
	rotate_player(player);
	translate_player(player, game);
	strafe_player(player, game);
}

===== src/graphics.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   graphics.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:49 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 12:51:46 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	put_pixel(int x, int y, int color, t_game *game)
{
	int	index;

	if (x >= WIDTH || y >= HEIGHT || x < 0 || y < 0)
		return ;
	index = y * game->data_img.size_line + x;
	game->data_img.pixels[index] = color;
}

void	clear_image(t_game *game)
{
	int	y;
	int	x;

	y = 0;
	while (y < HEIGHT)
	{
		x = 0;
		while (x < WIDTH)
		{
			put_pixel(x, y, 0x00000000, game);
			x++;
		}
		y++;
	}
}

void	draw_square(int x, int y, int color, t_game *game)
{
	int	i;

	i = 0;
	while (i < BLOCK)
	{
		put_pixel(x + i, y, color, game);
		put_pixel(x + i, y + BLOCK, color, game);
		put_pixel(x, y + i, color, game);
		put_pixel(x + BLOCK, y + i, color, game);
		i++;
	}
}

void	draw_map(t_game *game)
{
	int	row;
	int	col;

	row = 0;
	while (game->map[row])
	{
		col = 0;
		while (game->map[row][col])
		{
			if (game->map[row][col] == '1')
				draw_square(col * BLOCK, row * BLOCK, 0x0000FF, game);
			col++;
		}
		row++;
	}
}

===== src/raycast_draw.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast_draw.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/05/31 13:32:01 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/*
** Trace une tranche verticale texturée à l'écran.
*/
static void	draw_vertical_line(t_vline v, t_game *g, t_tex *tex)
{
	float	step;
	float	tex_pos;
	int		y;
	int		tex_y;

	step = (float)tex->height / (v.end - v.start + 1);
	tex_pos = 0.0f;
	if (v.start < 0)
	{
		tex_pos = -v.start * step;
		v.start = 0;
	}
	if (v.tex_x < 0)
		v.tex_x = 0;
	else if (v.tex_x >= tex->width)
		v.tex_x = tex->width - 1;
	y = v.start;
	while (y <= v.end && y < HEIGHT)
	{
		tex_y = (int)tex_pos & (tex->height - 1);
		tex_pos += step;
		put_pixel(v.x, y++, tex->pixels[tex_y * tex->width + v.tex_x], g);
	}
}

/*
** Sélectionne la texture en fonction du côté touché (0=verticale,
	1=horizontal).
*/
static t_tex	*select_texture(t_game *g, int side, float ray_ang)
{
	if (side == 0)
	{
		if (cosf(ray_ang) > 0)
			return (&g->textures[EAST]);
		else
			return (&g->textures[WEST]);
	}
	else
	{
		if (sinf(ray_ang) > 0)
			return (&g->textures[SOUTH]);
		else
			return (&g->textures[NORTH]);
	}
}

/*
** Calcule l’intersection exacte du rayon avec le mur (valeur entre 0 et BLOCK).
*/
static float	compute_hit(t_player *p, float perp_dist, float ray_ang,
		int side)
{
	if (side == 0)
		return (p->y + sinf(ray_ang) * perp_dist * BLOCK);
	else
		return (p->x + cosf(ray_ang) * perp_dist * BLOCK);
}

/*
** Dessine une tranche (slice) en une seule instruction 'draw_vertical_line'.
*/
static void	draw_slice(int x, t_game *g, float out[2], float ray_ang)
{
	float	perp_dist;
	t_tex	*tex;
	t_vline	v;

	perp_dist = out[0];
	v.start = (HEIGHT - (int)(DIST_PROJ_PLANE / perp_dist)) / 2;
	v.end = v.start + (int)(DIST_PROJ_PLANE / perp_dist);
	v.x = x;
	tex = select_texture(g, (int)out[1], ray_ang);
	v.tex_x = (int)(fmodf(compute_hit(&g->player, perp_dist, ray_ang,
					(int)out[1]), BLOCK) / BLOCK * tex->width);
	draw_vertical_line(v, g, tex);
}

void	draw_line(t_player *p, t_game *g, float ray_ang, int x)
{
	float	out[2];

	cast_ray(p, ray_ang, g, out);
	if (!DEBUG)
		draw_slice(x, g, out, ray_ang);
}

===== src/text.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   text.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 11:59:24 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/30 18:05:56 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	fill_paths(char *paths[NBR_TEX], t_config *cfg)
{
	paths[0] = cfg->no_texture;
	paths[1] = cfg->so_texture;
	paths[2] = cfg->we_texture;
	paths[3] = cfg->ea_texture;
}

void	text_load(t_game *game)
{
	int		i;
	char	*paths[NBR_TEX];
	char	*addr;

	i = 0;
	fill_paths(paths, &game->config);
	while (i < NBR_TEX)
	{
		if (!paths[i] || paths[i][0] == '\0')
			error_exit_game(game, "Error\nMissing texture path\n");
		if (ft_strlen(paths[i]) < 4 || ft_strcmp(paths[i] + ft_strlen(paths[i])
				- 4, ".xpm") != 0)
			error_exit_game(game, "Error\nTexture file must end with .xpm\n");
		game->textures[i].img = mlx_xpm_file_to_image(game->mlx, paths[i],
				&game->textures[i].width, &game->textures[i].height);
		if (!game->textures[i].img)
			error_exit_game(game, "Error\nCannot load texture\n");
		addr = mlx_get_data_addr(game->textures[i].img, &game->textures[i].bpp,
				&game->textures[i].size_line, &game->textures[i].endian);
		game->textures[i].pixels = (int *)addr;
		game->textures[i].size_line /= (game->textures[i].bpp / 8);
		i++;
	}
}

===== src/close.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:48 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:43:03 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	close_window(t_game *game)
{
	mlx_destroy_window(game->mlx, game->win);
	mlx_destroy_display(game->mlx);
	free(game->mlx);
	exit(0);
}

===== src/start_mlx.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_mlx.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:10:47 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 13:38:12 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/*
** Initialise MLX, la fenêtre et l’image.
** Retourne 1 si tout s'est bien passé, -1 sinon.
*/
static int	init_mlx_components(t_game *game)
{
	char	*addr;

	game->mlx = mlx_init();
	if (!game->mlx)
	{
		printf("Erreur : Init mlx\n");
		return (-1);
	}
	game->win = mlx_new_window(game->mlx, WIDTH, HEIGHT, "Cub3D");
	if (!game->win)
	{
		printf("Erreur : new_window\n");
		mlx_destroy_display(game->mlx);
		free(game->mlx);
		return (-1);
	}
	game->data_img.img = mlx_new_image(game->mlx, WIDTH, HEIGHT);
	if (!game->data_img.img)
	{
		printf("Erreur : new_img\n");
		mlx_destroy_window(game->mlx, game->win);
		mlx_destroy_display(game->mlx);
		free(game->mlx);
		return (-1);
	}
	addr = mlx_get_data_addr(game->data_img.img,
			&game->data_img.bpp,
			&game->data_img.size_line,
			&game->data_img.endian);
	game->data_img.pixels = (int *)addr;
	game->data_img.size_line /= (game->data_img.bpp / 8);
	return (1);
}

int	start_mlx(t_game *game)
{
	if (init_mlx_components(game) == -1)
		return (-1);
	game->player = get_coord(game);
	text_load(game);
	mlx_hook(game->win, 2, 1L << 0, key_press, game);
	mlx_hook(game->win, 3, 1L << 1, key_release, game);
	mlx_hook(game->win, 17, 0, close_window, game);
	mlx_loop_hook(game->mlx, draw_loop, game);
	mlx_loop(game->mlx);
	return (1);
}

===== src/init_game.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_game.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 17:37:16 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 13:39:56 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/*
** Initialise les textures à NULL ou 0.
*/
static void	init_textures(t_tex textures[NBR_TEX])
{
	int	i;

	i = 0;
	while (i < NBR_TEX)
	{
		textures[i].img = NULL;
		textures[i].pixels = NULL;
		textures[i].width = 0;
		textures[i].height = 0;
		textures[i].bpp = 0;
		textures[i].size_line = 0;
		textures[i].endian = 0;
		i++;
	}
}

void	init_structs(t_game *game)
{
	int	i;

	i = 0;
	ft_memset(game, 0, sizeof(*game));
	game->mlx = NULL;
	game->win = NULL;
	game->data_img.img = NULL;
	game->data_img.pixels = NULL;
	game->data_img.bpp = 0;
	game->data_img.size_line = 0;
	game->data_img.endian = 0;
	game->config.no_texture = NULL;
	game->config.so_texture = NULL;
	game->config.we_texture = NULL;
	game->config.ea_texture = NULL;
	while (i < 3)
	{
		game->config.floor_color[i] = -1;
		game->config.ceiling_color[i] = -1;
		i++;
	}
	game->map = NULL;
	game->player.x = WIDTH / 2;
	game->player.y = HEIGHT / 2;
	game->player.angle = -PI / 2;
	game->player.key_up = false;
	game->player.key_down = false;
	game->player.key_left = false;
	game->player.key_right = false;
	game->player.left_rotate = false;
	game->player.right_rotate = false;
	init_textures(game->textures);
}

===== src/raycast_dda.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycas_dda.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 11:03:27 by jdecarro          #+#    #+#             */
/*   Updated: 2025/04/30 11:03:27 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	setup_ray(t_player *p, float ray_ang, t_ray *r)
{
	r->map_x = (int)(p->x / BLOCK);
	r->map_y = (int)(p->y / BLOCK);
	r->rdx = cosf(ray_ang);
	r->rdy = sinf(ray_ang);
	r->ddx = fabsf(1.0f / r->rdx);
	r->ddy = fabsf(1.0f / r->rdy);
}

static void	init_step(t_player *p, t_ray *r)
{
	if (r->rdx < 0)
	{
		r->sx = -1;
		r->sdx = (p->x / BLOCK - r->map_x) * r->ddx;
	}
	else
	{
		r->sx = 1;
		r->sdx = (r->map_x + 1.0f - p->x / BLOCK) * r->ddx;
	}
	if (r->rdy < 0)
	{
		r->sy = -1;
		r->sdy = (p->y / BLOCK - r->map_y) * r->ddy;
	}
	else
	{
		r->sy = 1;
		r->sdy = (r->map_y + 1.0f - p->y / BLOCK) * r->ddy;
	}
}

static void	perform_dda(t_game *g, t_ray *r)
{
	while (true)
	{
		if (r->sdx < r->sdy)
		{
			r->sdx += r->ddx;
			r->map_x += r->sx;
			r->side = 0;
		}
		else
		{
			r->sdy += r->ddy;
			r->map_y += r->sy;
			r->side = 1;
		}
		if (g->map[r->map_y] && r->map_x >= 0
			&& r->map_x < (int)ft_strlen(g->map[r->map_y])
			&& g->map[r->map_y][r->map_x] == '1')
			break ;
	}
}

static void	compute_perp(t_player *p, t_ray *r, float out[2])
{
	if (r->side == 0)
		out[0] = (r->map_x - p->x / BLOCK + (1 - r->sx) / 2.0f) / r->rdx;
	else
		out[0] = (r->map_y - p->y / BLOCK + (1 - r->sy) / 2.0f) / r->rdy;
	out[1] = (float)r->side;
}

void	cast_ray(t_player *p, float ray_ang, t_game *g, float out[2])
{
	t_ray	r;

	setup_ray(p, ray_ang, &r);
	init_step(p, &r);
	perform_dda(g, &r);
	compute_perp(p, &r, out);
}

===== src/parse/append_map.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   append_map.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:23 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:40:22 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static int	count_lines(char **map)
{
	int	cnt;

	cnt = 0;
	while (map && map[cnt])
		cnt++;
	return (cnt);
}

static char	**alloc_and_copy(char **old_map, int count)
{
	int		i;
	char	**new_map;

	new_map = malloc(sizeof(char *) * (count + 2));
	if (!new_map)
	{
		ft_putstr_fd(ERR_MAP_MALLOC, 2);
		exit(EXIT_FAILURE);
	}
	i = 0;
	while (old_map && old_map[i])
	{
		new_map[i] = old_map[i];
		i++;
	}
	new_map[i] = NULL;
	if (old_map)
		free(old_map);
	return (new_map);
}

void	append_map_line(t_game *game, char *cpy_line)
{
	int		count;
	char	**new_map;

	count = count_lines(game->map);
	new_map = alloc_and_copy(game->map, count);
	new_map[count] = cpy_line;
	new_map[count + 1] = NULL;
	game->map = new_map;
}

===== src/parse/parse_color.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_color.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:12 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 13:43:10 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static char	**split_and_validate_color(char *str, t_parser *parser)
{
	char	**tokens;
	int		count;
	int		i;

	tokens = ft_split(str, ',');
	if (!tokens)
		error_and_exit(parser, ERR_MEM_ALLOC_COLOR);
	count = 0;
	while (tokens[count])
		count++;
	if (count != 3)
		error_and_exit_free(parser, tokens, ERR_INVALID_COLOR_FORMAT);
	i = 0;
	while (i < 3)
	{
		if (!tokens[i])
			error_and_exit_free(parser, tokens,
				"Error\nFormat de couleur invalide\n");
		i++;
	}
	return (tokens);
}

static void	assign_color(int *target, char **tokens, t_parser *parser)
{
	int	i;

	if (target[0] != -1)
		error_and_exit_free(parser, tokens, "Error\nCouleur déjà définie.\n");
	i = 0;
	while (i < 3)
	{
		target[i] = ft_atoi(tokens[i]);
		check_color_value(target[i], parser);
		i++;
	}
}

void	parse_color(t_game *game, char *clean_line, char *color_str,
		t_parser *parser)
{
	char	**tokens;

	tokens = split_and_validate_color(color_str, parser);
	if (!ft_strncmp(clean_line, "F ", 2))
		assign_color(game->config.floor_color, tokens, parser);
	else if (!ft_strncmp(clean_line, "C ", 2))
		assign_color(game->config.ceiling_color, tokens, parser);
	else
	{
		free_split(tokens);
		error_and_exit(parser, ERR_UNKNOWN_COLOR_IDENTIFIER);
	}
	free_split(tokens);
}

===== src/parse/free_2.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 15:36:12 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:41:40 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	cleanup_get_next_line(void)
{
	get_next_line(-42);
}

void	free_split(char **tokens)
{
	int	i;

	i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}

===== src/parse/check_map_help3.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:35 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:43:11 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	print_line_error_empty(int row, t_parser *parser)
{
	ft_putstr_fd("Error\nLigne : ", 2);
	ft_putnbr_fd(row, 2);
	ft_putstr_fd(" est vide.\n", 2);
	exit_text_with_error("", parser);
}

static void	print_line_error_end(int row, t_parser *parser)
{
	ft_putstr_fd("Error\nLigne : ", 2);
	ft_putnbr_fd(row, 2);
	ft_putstr_fd(" ne finit pas par un mur '1'.\n", 2);
	exit_text_with_error("", parser);
}

static void	check_line_starts_with_wall(char *line, t_parser *parser)
{
	int	i;

	i = 0;
	while (line[i] == ' ' || line[i] == '\t')
		i++;
	if (line[i] != '1')
		exit_text_with_error(ERR_MAP_START_LINE, parser);
}

static void	check_line_ends_with_wall(char *line, int row, t_parser *parser)
{
	int	end;

	end = (int)strlen(line) - 1;
	while (end >= 0 && (line[end] == ' ' || line[end] == '\t'))
		end--;
	if (end < 0)
		print_line_error_empty(row, parser);
	if (line[end] != '1')
		print_line_error_end(row, parser);
}

void	check_middle_line(char *line, int row, t_parser *parser)
{
	check_line_starts_with_wall(line, parser);
	check_line_ends_with_wall(line, row, parser);
}

===== src/parse/error.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 12:20:13 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	error_exit_game(t_game *game, char *msg)
{
	ft_putstr_fd(msg, 2);
	cleanup_before_exit(game);
	exit(EXIT_FAILURE);
}

void	exit_text_with_error(char *msg, t_parser *parser)
{
	ft_putstr_fd(msg, 2);
	cleanup_all(parser->game, parser);
	free(parser->state);
	exit(EXIT_FAILURE);
}

void	error_and_exit(t_parser *parser, char *msg)
{
	ft_putstr_fd(msg, 2);
	cleanup_get_next_line();
	cleanup_all(parser->game, parser);
	free(parser->state);
	exit(EXIT_FAILURE);
}

void	error_and_exit_free(t_parser *parser, char **tokens, char *msg)
{
	free_split(tokens);
	ft_putstr_fd(msg, 2);
	cleanup_get_next_line();
	cleanup_all(parser->game, parser);
	free(parser->state);
	exit(EXIT_FAILURE);
}

void	check_color_value(int value, t_parser *parser)
{
	if (value < 0 || value > 255)
	{
		ft_putstr_fd("Error:\nCouleur invalide: ", 2);
		ft_putnbr_fd(value, 2);
		ft_putchar_fd('\n', 2);
		exit_text_with_error("", parser);
	}
}

===== src/parse/check_map_help2.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:37:02 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/30 18:09:48 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	init_visited_map(t_mapinfo *info, t_parser *parser)
{
	int	r;

	info->visited = malloc(sizeof(bool *) * info->height);
	if (!info->visited)
		error_and_exit(parser, ERR_MAP_MALLOC);
	r = 0;
	while (r < info->height)
	{
		info->visited[r] = calloc(info->width, sizeof(bool));
		if (!info->visited[r])
			error_and_exit(parser, ERR_MAP_MALLOC);
		r++;
	}
}

void	free_mapinfo(t_mapinfo *info)
{
	int	r;

	r = 0;
	while (r < info->height)
	{
		free(info->map2d[r]);
		free(info->visited[r]);
		r++;
	}
	free(info->map2d);
	free(info->visited);
}

int	get_map_height(char **map)
{
	int	height;

	height = 0;
	while (map[height])
		height++;
	return (height);
}

void	check_map_empty(int height)
{
	if (height == 0)
	{
		ft_putstr_fd(ERR_MAP_EMPTY, 2);
		exit(EXIT_FAILURE);
	}
}

int	get_max_width(char **map, int height)
{
	int	i;
	int	len;
	int	width;

	width = 0;
	i = 0;
	while (i < height)
	{
		len = (int)ft_strlen(map[i]);
		if (len > width)
			width = len;
		i++;
	}
	return (width);
}

===== src/parse/proc_color.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_color.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:34 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:42:23 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	process_color_line(t_game *game, t_parser *parser)
{
	parser->match_color = 1;
	if (parser->clean_line[0] == 'F')
		parser->trimmed = ft_strtrim(parser->clean_line + 2, " \t\n");
	else if (parser->clean_line[0] == 'C')
		parser->trimmed = ft_strtrim(parser->clean_line + 2, " \t\n");
	if (!parser->trimmed)
	{
		ft_putstr_fd(ERR_MEM_ALLOC_COLOR, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	parse_color(game, parser->clean_line, parser->trimmed, parser);
	free(parser->trimmed);
	parser->trimmed = NULL;
}

===== src/parse/final_check.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   final_check.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 20:19:21 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 11:23:13 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	check_textures(t_game *game, t_parser *parser)
{
	if (!game->config.no_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_NO);
	if (!game->config.so_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_SO);
	if (!game->config.ea_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_EA);
	if (!game->config.we_texture)
		error_and_exit(parser, ERR_TEXTURE_NOT_DEFINED_WE);
}

static void	check_colors(t_game *game, t_parser *parser)
{
	if (game->config.floor_color[0] == -1)
		error_and_exit(parser, ERR_COLOR_NOT_DEFINED_F);
	if (game->config.ceiling_color[0] == -1)
		error_and_exit(parser, ERR_COLOR_NOT_DEFINED_C);
}

static void	check_map_presence(t_game *game, t_parser *parser)
{
	if (!game->map)
		error_and_exit(parser, ERR_MAP_NOT_DEFINED);
}

void	final_check_config(t_game *game, t_parser *parser)
{
	if (!game)
		return ;
	check_textures(game, parser);
	check_colors(game, parser);
	check_map_presence(game, parser);
}

===== src/parse/parse_text.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_text.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:26 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/30 15:39:15 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	assign_no(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.no_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_NO, parser);
}

static void	assign_so(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.so_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_SO, parser);
}

static void	assign_we(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.we_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_WE, parser);
}

static void	assign_ea(t_game *game, t_parser *parser)
{
	assign_if_not_defined(&game->config.ea_texture, parser->trimmed,
		ERR_TEXTURE_ALREADY_DEFINED_EA, parser);
}

void	assign_texture(t_game *game, t_parser *parser)
{
	if (!ft_strncmp(parser->clean_line, "NO ", 3))
		assign_no(game, parser);
	else if (!ft_strncmp(parser->clean_line, "SO ", 3))
		assign_so(game, parser);
	else if (!ft_strncmp(parser->clean_line, "WE ", 3))
		assign_we(game, parser);
	else if (!ft_strncmp(parser->clean_line, "EA ", 3))
		assign_ea(game, parser);
}

===== src/parse/parse_helper2.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:42:10 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	assign_if_not_defined(char **texture_field, char *trimmed,
	char *error_msg, t_parser *parser)
{
	if (*texture_field != NULL)
	{
		ft_putstr_fd(error_msg, 2);
		free(*texture_field);
		*texture_field = NULL;
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	*texture_field = ft_strdup(trimmed);
	if (*texture_field == NULL)
		exit_text_with_error(error_msg, parser);
}

void	process_map_line(t_game *game, t_parser *parser)
{
	if (ft_strlen(parser->clean_line) == 0)
	{
		handle_empty_line(parser);
		return ;
	}
	check_map_errors(parser);
	parser->map_started = true;
	append_map_line(game, ft_strtrim(parser->line, "\n"));
}

void	handle_empty_line(t_parser *parser)
{
	if (parser->map_started)
	{
		parser->map_is_done = true;
		parser->empty_line_after_map = true;
	}
}

void	check_map_errors(t_parser *parser)
{
	if (parser->map_is_done)
	{
		ft_putstr_fd(ERR_MAP_ADD, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	if (parser->empty_line_after_map)
	{
		ft_putstr_fd(ERR_MAP_BAD, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
	if (!parser->match_text || !parser->match_color)
	{
		ft_putstr_fd(ERR_MAP_POS, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

===== src/parse/parse.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:30 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 13:46:34 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	open_map_file(char *file_name)
{
	int		fd;
	size_t	len;

	len = ft_strlen(file_name);
	if (len < 4 || ft_strcmp(file_name + len - 4, ".cub") != 0)
	{
		ft_putstr_fd("Error:\nFichier invalide. L'extension doit être '.cub'\n",
			2);
		return (-1);
	}
	fd = open(file_name, O_RDONLY);
	if (fd == -1)
	{
		ft_putstr_fd(ERR_OPEN_FILE, 2);
		ft_putstr_fd(file_name, 2);
		ft_putstr_fd("\n", 2);
	}
	return (fd);
}

void	process_line(t_game *game, t_parser *parser)
{
	if (!parser->clean_line || ft_strlen(parser->clean_line) == 0)
	{
		handle_empty_line(parser);
		return ;
	}
	if (ft_strlen(parser->clean_line) > 0 && (!ft_strncmp(parser->clean_line,
				"NO ", 3) || !ft_strncmp(parser->clean_line, "SO ", 3)
			|| !ft_strncmp(parser->clean_line, "WE ", 3)
			|| !ft_strncmp(parser->clean_line, "EA ", 3)))
	{
		process_texture_line(game, parser);
	}
	else if (ft_strlen(parser->clean_line) > 0
		&& (!ft_strncmp(parser->clean_line, "F ", 2)
			|| !ft_strncmp(parser->clean_line, "C ", 2)))
	{
		process_color_line(game, parser);
	}
	else
		process_map_line(game, parser);
}

static void	parse_loop(t_game *game, t_parser *parser, int fd)
{
	parser->line = get_next_line(fd);
	if (!parser->line)
	{
		ft_putstr_fd(ERR_MAP_EMPTY, 2);
		close(fd);
		cleanup_get_next_line();
		exit(EXIT_FAILURE);
	}
	while (parser->line)
	{
		parser->clean_line = ft_strtrim(parser->line, " \t\n");
		process_line(game, parser);
		if (parser->clean_line)
		{
			free(parser->clean_line);
			parser->clean_line = NULL;
		}
		free(parser->line);
		parser->line = NULL;
		parser->line = get_next_line(fd);
	}
	cleanup_get_next_line();
}

static int	check_parsing(t_game *game, t_parser *parser)
{
	if (game->map)
	{
		check_validate_map(game, parser);
		final_check_config(game, parser);
		return (0);
	}
	else
	{
		ft_putstr_fd(ERR_MAP_NOT_DEFINED, 2);
		return (1);
	}
}

/*
** Tente d’ouvrir le fichier et gère l’erreur si l’extension n’est pas .cub
** ou si l’ouverture échoue. Retourne le descripteur ou -1 en cas d’erreur.
*/
static int	open_and_validate(char *file_name, t_parser *parser)
{
	int	fd;

	fd = open_map_file(file_name);
	if (fd == -1)
	{
		cleanup_get_next_line();
		free(parser->state);
		return (-1);
	}
	return (fd);
}

int	ft_parse(t_game *game, char *file_name)
{
	t_parser	parser;
	int			fd;
	int			result;

	init_parser(&parser, game);
	game->map = NULL;
	fd = open_and_validate(file_name, &parser);
	if (fd == -1)
		return (EXIT_FAILURE);
	parse_loop(game, &parser, fd);
	result = check_parsing(game, &parser);
	close(fd);
	if (result != EXIT_SUCCESS)
	{
		cleanup_get_next_line();
		cleanup_all(game, &parser);
		free(parser.state);
		return (result);
	}
	cleanup_get_next_line();
	free(parser.state);
	return (result);
}

===== src/parse/proc_text.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_text.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:37 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:42:28 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

static void	trim_texture_path(t_parser *parser)
{
	if (parser->clean_line[0] == 'N' && parser->clean_line[1] == 'O')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'S' && parser->clean_line[1] == 'O')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'W' && parser->clean_line[1] == 'E')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
	else if (parser->clean_line[0] == 'E' && parser->clean_line[1] == 'A')
		parser->trimmed = ft_strtrim(parser->clean_line + 3, " \t\n");
}

static void	check_trimmed_not_null(t_parser *parser)
{
	if (parser->trimmed == NULL)
	{
		ft_putstr_fd(ERR_MEM_ALLOC_TEXTURE, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

static void	check_trimmed_not_empty(t_parser *parser)
{
	if (ft_strlen(parser->trimmed) == 0)
	{
		ft_putstr_fd(ERR_EMPTY_TEXTURE_PATH, 2);
		cleanup_all(parser->game, parser);
		exit(EXIT_FAILURE);
	}
}

void	process_texture_line(t_game *game, t_parser *parser)
{
	parser->match_text = 1;
	trim_texture_path(parser);
	check_trimmed_not_null(parser);
	check_trimmed_not_empty(parser);
	check_access(parser);
	assign_texture(game, parser);
	free(parser->trimmed);
}

===== src/parse/init.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:59 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 13:50:36 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	copy_and_pad_line(char *dest, char *src, int width)
{
	int	len;
	int	c;

	len = (int)ft_strlen(src);
	c = 0;
	while (c < len)
	{
		dest[c] = src[c];
		c++;
	}
	while (c < width)
	{
		dest[c] = ' ';
		c++;
	}
	dest[width] = '\0';
}

/*
** Initialise la structure mapinfo à partir de game->map.
** Récupère la hauteur (h) et la largeur (w) en calculant automatiquement.
*/
void	init_mapinfo_struct(t_mapinfo *info, t_game *game, t_parser *parser)
{
	int	r;
	int	h;
	int	w;

	h = get_map_height(game->map);
	w = get_max_width(game->map, h);
	info->height = h;
	info->width = w;
	info->map2d = malloc(sizeof(char *) * h);
	if (!info->map2d)
		error_and_exit(parser, ERR_MAP_MALLOC);
	r = 0;
	while (r < h)
	{
		info->map2d[r] = malloc(sizeof(char) * (w + 1));
		if (!info->map2d[r])
			error_and_exit(parser, ERR_MAP_MALLOC);
		copy_and_pad_line(info->map2d[r], game->map[r], w);
		r++;
	}
}

void	init_parser(t_parser *parser, t_game *game)
{
	parser->match_text = 0;
	parser->match_color = 0;
	parser->map_started = false;
	parser->map_is_done = false;
	parser->empty_line_after_map = false;
	parser->line = NULL;
	parser->clean_line = NULL;
	parser->trimmed = NULL;
	parser->game = game;
	parser->state = malloc(sizeof(t_cleanup_state));
	if (parser->state)
	{
		parser->state->game_cleaned = false;
		parser->state->parser_cleaned = false;
	}
}

===== src/parse/parse_helper1.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:24:16 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:42:05 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	is_integer(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

void	check_access(t_parser *parser)
{
	int		fd;
	char	*trimmed;

	trimmed = parser->trimmed;
	fd = open(trimmed, O_RDONLY);
	if (fd == -1 || ft_strcmp(trimmed + ft_strlen(trimmed) - 4, ".xpm"))
	{
		ft_putstr_fd("Error\nfichier de texture inaccessible: ", 2);
		ft_putstr_fd(trimmed, 2);
		cleanup_all(parser->game, parser);
		close(fd);
		exit(EXIT_FAILURE);
	}
	close(fd);
}

===== src/parse/check_valid_map.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_valid_map.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:41 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/31 14:13:12 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/* ---------- 1) Bordures de la carte -------------------------------------- */
static void	check_map_borders(char **map, int h, t_parser *p)
{
	int			row;
	t_line_info	inf;

	row = 0;
	inf.first = 0;
	inf.last = h - 1;
	while (row < h)
	{
		inf.row = row;
		check_line_borders(map[row], inf, p);
		row++;
	}
}

/* ---------- 2) Traitement d’un caractère --------------------------------- */
static void	store_player(char ch, int r, int c, t_player_data *d)
{
	if (!is_valid_map_char(ch))
		error_and_exit(d->parser, ERR_MAP_INVALID_CHAR);
	if (ch == 'N' || ch == 'S' || ch == 'E' || ch == 'W')
	{
		(*d->count)++;
		*d->row = r;
		*d->col = c;
		d->info->map2d[r][c] = '0';
	}
}

/* Parcourt toute la map pour trouver le joueur */
static void	scan_map_for_player(t_mapinfo *info, t_player_data *d)
{
	int		r;
	int		c;
	char	ch;

	r = 0;
	while (r < info->height)
	{
		c = 0;
		while (c < info->width)
		{
			ch = info->map2d[r][c];
			store_player(ch, r, c, d);
			c++;
		}
		r++;
	}
}

/* ---------- 3) Validation : un seul joueur ------------------------------- */
static void	validate_and_get_player(t_mapinfo *info, int *pr,
			int *pc, t_parser *p)
{
	t_player_data	d;
	int				player_cnt;

	player_cnt = 0;
	d.count = &player_cnt;
	d.row = pr;
	d.col = pc;
	d.info = info;
	d.parser = p;
	scan_map_for_player(info, &d);
	if (player_cnt != 1)
		error_and_exit(p, ERR_MAP_TEXT_MORE_THAN_ONE);
}

/* ---------- 4) Fonction principale --------------------------------------- */
void	check_validate_map(t_game *g, t_parser *p)
{
	t_mapinfo	info;
	int			player_r;
	int			player_c;
	int			height;

	height = get_map_height(g->map);
	check_map_empty(height);
	check_map_borders(g->map, height, p);
	init_mapinfo_struct(&info, g, p);
	validate_and_get_player(&info, &player_r, &player_c, p);
	init_visited_map(&info, p);
	if (!dfs_closed(&info, player_r, player_c))
		error_and_exit(p, ERR_MAP_NOT_CLOSE);
	free_mapinfo(&info);
}

===== src/parse/check_map_help1.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_map_help1.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:35 by mbendidi          #+#    #+#             */
/*   Updated: 2025/04/09 16:40:31 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

bool	is_only_spaces(char *line)
{
	int	i;

	i = 0;
	while (line[i])
	{
		if (line[i] != ' ' && line[i] != '\t')
			return (false);
		i++;
	}
	return (true);
}

void	check_first_or_last_line(char *line, t_parser *parser)
{
	int	i;

	i = 0;
	while (line[i] == ' ' || line[i] == '\t')
		i++;
	while (line[i] != '\0')
	{
		while (line[i] != '\0' && line[i] != ' ' && line[i] != '\t')
		{
			if (line[i] != '1')
				exit_text_with_error(ERR_MAP_FIRST_LAST_LINE, parser);
			i++;
		}
		while (line[i] == ' ' || line[i] == '\t')
			i++;
	}
}

void	check_line_borders(char *line, t_line_info info, t_parser *parser)
{
	if (is_only_spaces(line))
	{
		ft_putstr_fd("Error\nLigne : ", 2);
		ft_putnbr_fd(info.row, 2);
		ft_putstr_fd(" vide ou que des espaces.\n", 2);
		exit_text_with_error("", parser);
	}
	if (info.row == info.first || info.row == info.last)
		check_first_or_last_line(line, parser);
	else
		check_middle_line(line, info.row, parser);
}

bool	dfs_closed(t_mapinfo *info, int r, int c)
{
	if (r < 0 || r >= info->height || c < 0 || c >= info->width)
		return (false);
	if (info->visited[r][c] || info->map2d[r][c] == '1')
		return (true);
	info->visited[r][c] = true;
	if (!dfs_closed(info, r - 1, c))
		return (false);
	if (!dfs_closed(info, r + 1, c))
		return (false);
	if (!dfs_closed(info, r, c - 1))
		return (false);
	if (!dfs_closed(info, r, c + 1))
		return (false);
	return (true);
}

bool	is_valid_map_char(char c)
{
	return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W'
		|| c == ' ');
}

===== src/parse/free_1.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 19:23:56 by mbendidi          #+#    #+#             */
/*   Updated: 2025/05/04 19:32:06 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	cleanup_parser_resources(t_parser *parser)
{
	if (!parser)
		return ;
	if (parser->line)
	{
		free(parser->line);
		parser->line = NULL;
	}
	if (parser->clean_line)
	{
		free(parser->clean_line);
		parser->clean_line = NULL;
	}
	if (parser->trimmed != NULL)
	{
		free(parser->trimmed);
		parser->trimmed = NULL;
	}
}

void	free_map(char **map)
{
	int	i;

	i = 0;
	if (!map)
		return ;
	while (map[i])
	{
		free(map[i]);
		i++;
	}
	free(map);
}

void	free_config(t_config *config)
{
	if (!config)
		return ;
	if (config->no_texture)
		free(config->no_texture);
	if (config->so_texture)
		free(config->so_texture);
	if (config->we_texture)
		free(config->we_texture);
	if (config->ea_texture)
	{
		free(config->ea_texture);
	}
	config->no_texture = NULL;
	config->so_texture = NULL;
	config->we_texture = NULL;
	config->ea_texture = NULL;
}

void	cleanup_all(t_game *game, t_parser *parser)
{
	if (game && parser && parser->state && !parser->state->game_cleaned)
	{
		parser->state->game_cleaned = true;
		free_config(&game->config);
		if (game->map)
		{
			free_map(game->map);
			game->map = NULL;
		}
	}
	if (parser && parser->state && !parser->state->parser_cleaned)
	{
		parser->state->parser_cleaned = true;
		parser->trimmed = NULL;
		cleanup_parser_resources(parser);
	}
	if (parser && parser->state)
	{
		free(parser->state);
		parser->state = NULL;
	}
}

void	cleanup_before_exit(t_game *game)
{
	free_config(&game->config);
	free_map(game->map);
	if (game->mlx)
	{
		if (game->win)
			mlx_destroy_window(game->mlx, game->win);
	}
}
